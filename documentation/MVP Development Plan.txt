## MVP Scope Definition

**Target:** Fully playable game loop demonstrating all core mechanics  
**Completion Time:** 2-3 hours of gameplay  
**Content:** 5 Space Defender levels, 5 unique minigames (cloned to 200+ games), basic automation  
**Engine:** Love2D with MVC architecture  

**MVP Success Criteria:**
- Formula system is clear and motivating
- Performance affects bullet power and tokens visibly
- Player can unlock games, play them, and see performance improve power
- Automation works and generates tokens based on formulas
- Space Defender levels 1-5 are completable
- Progression feels satisfying with no grinding walls
- Game is stable (no crashes, saves work correctly)
- Runs at 60 FPS with 150+ bullets on screen

---

## Phase 1.1: Foundation & Architecture (Days 1-3)

### 1.1.1 Project Initialization
- Create Love2D project folder
- Create conf.lua file (window settings, modules, version)
- Initialize Git repository with .gitignore
- Create complete folder structure:
  - /src/models/
  - /src/views/
  - /src/controllers/
  - /src/states/
  - /src/games/
  - /src/utils/
  - /lib/
  - /assets/sprites/
  - /assets/sounds/
  - /assets/fonts/
  - /assets/data/
- Make initial commit

### 1.1.2 External Libraries
- Add middleclass library to /lib/class.lua
- Add json.lua to /lib/json.lua
- Test both libraries load correctly in main.lua

### 1.1.3 Main Entry Point
- Create main.lua with love.load(), love.update(dt), love.draw()
- Initialize game controller
- Set up basic window and rendering
- Test game window opens without errors

### 1.1.4 State Machine Core
- Create /src/controllers/state_machine.lua
- Implement StateMachine class with:
  - states table
  - current_state reference
  - register(state_name, state_object) method
  - switch(state_name, ...) method
  - update(dt) method
  - draw() method
  - keypressed(key) method
  - mousepressed(x, y, button) method
- Test with two dummy states

---

## Phase 1.2: Data Models (Days 3-5)

### 1.2.1 Player Data Model
- Create /src/models/player_data.lua
- Implement PlayerData class with properties:
  - tokens (number)
  - unlocked_games (table of game IDs)
  - completed_games (table of game IDs with performance data)
  - game_performance (table: game_id → {metric1, metric2, best_score})
  - space_defender_level (number)
  - vm_slots (number)
  - active_vms (table of VM assignments)
  - upgrades (table of upgrade levels)
- Implement methods:
  - addTokens(amount)
  - spendTokens(amount)
  - hasTokens(amount)
  - unlockGame(game_id)
  - isGameUnlocked(game_id)
  - updateGamePerformance(game_id, metrics, formula_result)
  - getGamePerformance(game_id)
  - getGamePower(game_id)
  - unlockLevel(level)
  - purchaseVM()
  - purchaseUpgrade(type)
- Test all methods

### 1.2.2 Game Data Model
- Create /src/models/game_data.lua
- Implement GameData class
- Define game object structure:
  - id (unique identifier)
  - display_name
  - game_class (class name to instantiate)
  - tier (trash/mid/premium)
  - category (action/puzzle/sports/etc)
  - unlock_cost (tokens)
  - formula_string (human-readable formula)
  - formula_function (actual calculation function)
  - metrics_tracked (array of metric names)
  - auto_play_performance (table of typical auto-play metrics)
  - bullet_fire_rate (shots per second)
  - bullet_sprite (sprite identifier)
  - bullet_special (special property if any)
  - thumbnail (sprite identifier)
  - variant_of (base game ID if clone)
  - variant_multiplier (multiplier for clone)
- Implement methods:
  - loadGames() (hardcoded for MVP)
  - getGame(game_id)
  - getAllGames()
  - getGamesByCategory(category)
  - getGamesByTier(tier)
  - generateClones(base_game_id, count, multipliers)
  - calculatePower(game_id, metrics)
  - calculateTokenRate(game_id, metrics)
- Test loading and querying

### 1.2.3 Formula System Implementation
- Create formula structure for each game
- Define metric tracking requirements per game type
- Implement formula calculation functions
- Create human-readable formula strings for display
- Define baseline performance for auto-completion (60-70% of strong performance)
- Test formula calculations with sample data
- Verify formulas produce reasonable power values
- Test auto-completion baseline produces fair results

### 1.2.4 Game Data Cloning System
- Implement clone generation in game_data.lua
- Takes base game, creates variants with different multipliers and difficulty
- Assign progressive multipliers (1x, 1.2x, 2x, 5x, 10x, 20x, 40x, etc.)
- **Assign progressive difficulty** (higher clones have harder mechanics)
- Create unique IDs for each clone
- Apply sprite variations
- Store difficulty scaling data (enemy speed, count, patterns, etc.)
- Test generating 200+ games from 5 base templates
- Test that higher-numbered clones are genuinely harder to complete

### 1.2.6 Save Manager
- Create /src/utils/save_manager.lua
- Implement save(player_data) function
- Implement load() function
- Save structure includes:
  - All player_data properties
  - Game performance records (manual and auto-completed)
  - Auto-completion status per game
  - VM assignments
  - Version number and timestamp
- Test saving and loading
- Test save file is valid JSON
- Test loading when no save exists
- Test auto-completion state persists correctly
- Create /src/utils/save_manager.lua
- Implement save(player_data) function
- Implement load() function
- Save structure includes:
  - All player_data properties
  - Game performance records
  - VM assignments
  - Version number and timestamp
- Test saving and loading
- Test save file is valid JSON
- Test loading when no save exists

---

## Phase 1.3: Base Minigame System (Days 5-8)

### 1.3.1 Base Game Class
- Create /src/games/base_game.lua
- Implement BaseGame class with properties:
  - data (game definition)
  - metrics (table tracking performance)
  - completed (boolean)
  - time_elapsed (number)
- Implement methods (overridable):
  - init()
  - update(dt)
  - draw()
  - keypressed(key)
  - mousepressed(x, y, button)
  - checkComplete()
  - onComplete()
  - getMetrics()
  - calculatePerformance()
- Test base class instantiation

### 1.3.2 Minigame State Handler
- Create /src/states/minigame_state.lua
- Implement MinigameState class with properties:
  - current_game (game instance)
  - completion_screen_visible (boolean)
  - previous_best (number)
  - current_performance (number)
- Implement methods:
  - enter(game_data) - instantiate game by class name
  - update(dt) - run game logic, check completion
  - draw() - render game and completion screen
  - onGameComplete() - calculate performance, update player_data, show results
  - keypressed(key) - forward to game, ESC to exit
  - mousepressed(x, y, button) - forward to game
- Test state switching and completion flow

### 1.3.3 First Minigame Template (Example: Space Shooter)
- Create /src/games/space_shooter.lua extending BaseGame
- Implement game-specific properties:
  - enemies (array)
  - player (object)
  - kills (number)
  - deaths (number)
  - difficulty_modifiers (from game_data.difficulty_level)
- Track metrics for formula: kills, deaths
- Implement space shooter gameplay with difficulty scaling:
  - **Low difficulty (1-10):** Few enemies, slow, simple patterns
  - **Medium difficulty (11-30):** More enemies, faster, some variation
  - **High difficulty (31-50):** Many enemies, fast, complex patterns, shoots back
- Apply variant sprite based on variant_modifiers
- Apply difficulty modifiers based on difficulty_level
- Formula: (Kills - Deaths) × variant_multiplier
- Test game is playable at all difficulty levels
- Test difficulty genuinely increases (can't brute-force hard variants)
- Test formula tracks metrics correctly

### 1.3.4 Additional Minigame Templates
Create 4 more unique minigame templates with different formulas and difficulty scaling:

**Example Template 2: Snake Game**
- Tracks: snake_length, survival_time
- Formula: (Snake Length × Survival Time ÷ 10) × variant_multiplier
- Difficulty scaling: Speed increases, obstacles added, less time

**Example Template 3: Memory Match**
- Tracks: matches_found, time_taken, perfect_matches
- Formula: (Matches Found × 10 - Time Taken + Perfect Matches × 5) × variant_multiplier
- Difficulty scaling: More cards, less time to memorize, cards shuffle

**Example Template 4: Dodge Game**
- Tracks: objects_dodged, collisions, perfect_dodges
- Formula: (Objects Dodged² ÷ (Collisions + 1)) × variant_multiplier
- Difficulty scaling: Faster objects, more objects, less warning

**Example Template 5: Hidden Object (Deterministic "Gimme")**
- Tracks: objects_found, time_bonus
- Formula: (Objects Found × Time Bonus) × variant_multiplier
- Same locations every time - easily optimizable
- Difficulty scaling: More objects, less time, similar-looking objects

Each template should:
- Track 2-4 relevant metrics
- Have clear performance goals
- Formula that rewards skill/optimization
- Support difficulty scaling for clones
- Be completable in 30 seconds - 2 minutes
- Support variant modifications
- Test at multiple difficulty levels

### 1.3.5 Performance Display & Auto-Completion Feedback
- Create performance result screen after game completion
- Show:
  - Metrics achieved (e.g., "Kills: 52, Deaths: 1")
  - Formula calculation (e.g., "(52 - 1) × 7 = 357")
  - Previous best comparison
  - Power increase/decrease
  - Token generation rate change
  - **Auto-completion notification** if this triggered auto-complete
- If game completion triggered auto-completion:
  - Show list of auto-completed games
  - Show baseline power for each
  - Show total power gained from family
  - Example: "Beat SS20! Auto-completed SS1-19: +5,000 total power"
- Add visual feedback for new records
- Add celebration for auto-completion triggers
- Test display shows all relevant info clearly
- Test auto-completion feedback is exciting and clear

---

## Phase 1.4: Game Launcher (Days 8-11)

### 1.4.1 Launcher State Structure
- Create /src/states/launcher_state.lua
- Implement LauncherState class with properties:
  - filtered_games (array)
  - selected_category (string)
  - scroll_offset (number)
  - hovered_game (game_id or nil)
  - selected_game (game object or nil)
  - detail_panel_open (boolean)
- Implement methods:
  - enter() - load and filter games
  - update(dt) - handle scrolling, hover states
  - draw() - render launcher UI
  - mousepressed(x, y, button) - handle clicks
  - keypressed(key) - handle ESC, shortcuts
  - updateFilter(category)
  - launchGame(game_id)
  - showGameDetails(game_id)

### 1.4.2 Launcher View Components
- Create /src/views/launcher_view.lua
- Implement drawing functions:
  - drawWindow(x, y, w, h, title) - Windows 98 style
  - drawGameGrid(x, y, games, player_data, scroll, hovered)
  - drawGameIcon(x, y, game, locked, hovered, auto_completed)
  - drawCategoryButtons(x, y, categories, selected)
  - drawTokenCounter(x, y, tokens)
  - drawGameDetailPanel(game, player_data)
- Game detail panel shows:
  - Game name and tier
  - **Difficulty indicator** (Easy/Medium/Hard/Brutal)
  - Unlock cost
  - **Formula display** (human-readable)
  - Current performance metrics (if played)
  - Current bullet power
  - **Auto-completion status** (if auto-completed vs manually played)
  - Auto-play power estimate
  - Token generation rate
  - Risk-reward indicator ("High risk, high reward!")
  - [UNLOCK] / [PLAY] / [REPLAY] buttons
- Visual indicators:
  - Auto-completed games: Special badge/color
  - Manually completed games: Different badge
  - Locked games: Lock icon
  - Higher difficulties: Warning indicators

### 1.4.3 Formula Display Implementation
- Create clear, readable formula displays
- Show formula with actual values filled in
- Highlight which metrics to improve
- Show comparison: current vs. potential
- Example display:
  ```
  POWER FORMULA: (Kills - Deaths) × 7
  
  Your Best Performance:
  - Kills: 52
  - Deaths: 1
  - Power: (52 - 1) × 7 = 357
  
  Auto-Play Estimate:
  - Power: ~250 (70% of best)
  - Token Rate: 250/minute
  
  [REPLAY TO IMPROVE]
  ```

### 1.4.4 Category Filtering
- Implement category buttons:
  - All Games
  - Action
  - Puzzle
  - Sports (if applicable)
  - By Tier (Trash, Mid, Premium)
  - By Difficulty (Easy 1-10, Medium 11-30, Hard 31-50)
  - By Status (Locked, Unlocked, Auto-Completed, Manually Completed)
- Filter games based on selection
- Reset scroll on category change
- Show game count for each filter
- Test filtering works correctly
- Test useful for finding games at your skill level

### 1.4.5 Game Unlock & Skip-Ahead Flow
- Implement unlock purchase prompt with risk assessment:
  - Show game difficulty
  - Show cost
  - Show potential reward (formula result estimate)
  - Show warning if difficulty might be too high
  - Example: "This costs 500 tokens (all you have!) and is Hard difficulty. Continue?"
- Check token balance
- Deduct tokens if sufficient
- Unlock game in player_data
- Update UI immediately
- Save game
- Test unlock flow
- Test players can unlock any game in available tier
- Test expensive unlocks feel like meaningful decisions

### 1.4.6 Game Launch Flow
- Check if game is unlocked
- If locked: show purchase prompt
- If unlocked: switch to minigame_state
- Pass game data to minigame_state
- Test launching games

---

## Phase 1.5: Space Defender Core (Days 11-16)

### 1.5.1 Space Defender State Setup
- Create /src/states/space_defender_state.lua
- Implement SpaceDefenderState class with properties:
  - current_level (number)
  - player_ship (object: x, y, hp, max_hp, speed, bombs)
  - enemies (array)
  - bullets (array from bullet_system)
  - waves (array of wave definitions)
  - current_wave (number)
  - boss (object or nil)
  - boss_active (boolean)
  - paused (boolean)
  - level_complete (boolean)
- Implement methods:
  - enter(level_number)
  - update(dt)
  - draw()
  - keypressed(key)
  - onLevelComplete()
  - onLevelFailed()

### 1.5.2 Player Ship & Controls
- Implement player ship object with:
  - Position (x, y)
  - Dimensions (width, height, hitbox)
  - Stats (HP, speed, bombs)
  - Movement (WASD or arrow keys)
- Implement movement in update(dt)
- Clamp to screen bounds
- Implement takeDamage(amount)
- Implement useBomb()
- Test movement feels responsive

### 1.5.3 Bullet System Integration
- Create /src/models/bullet_system.lua
- Implement BulletSystem class with properties:
  - bullet_types (loaded from completed games)
  - active_bullets (array)
  - fire_timers (per bullet type)
- Implement methods:
  - loadBulletTypes(player_data, game_data) - reads completed games, gets formulas, calculates power
  - update(dt, player_pos, enemies) - spawn bullets, move bullets, check collisions
  - draw() - render all bullets
  - clear() - remove all bullets (bomb)
- Each bullet has:
  - damage (from formula result × level bonuses)
  - fire_rate (from game data × level bonuses)
  - position, velocity
  - sprite
  - special property
- Test bullets spawn at correct rates
- Test bullet power reflects game performance

### 1.5.4 Enemy System
- Implement enemy object with:
  - Position, dimensions
  - HP (scales with level)
  - Movement pattern (straight, zigzag, sine)
  - Speed
  - Damage to player
- Implement enemy spawning system
- Implement enemy update (movement, collision with player/bullets)
- Implement enemy death
- Test enemy spawning and behavior

### 1.5.5 Wave System
- Define wave structure:
  - enemy_types (array)
  - spawn_count (total enemies)
  - spawn_rate (seconds between spawns)
- Create wave definitions for 5 levels
- Implement wave spawning logic
- Implement progression to next wave
- Test wave system spawns correctly

### 1.5.6 Boss System
- Implement boss object with:
  - Large HP pool (scales with level)
  - Attack patterns
  - Phase changes at HP thresholds
  - Unique sprite
- Create 5 unique bosses for levels 1-5
- Implement boss spawn after waves complete
- Implement boss attacks (spawn bullets, charge, etc.)
- Implement boss defeat sequence
- Test boss fights feel challenging but fair

### 1.5.7 Collision Detection
- Create /src/utils/collision.lua
- Implement AABB collision detection
- Check bullet-enemy collisions
- Check enemy-player collisions
- Check boss-bullet collisions
- Optimize collision checking
- Test collision accuracy

### 1.5.8 Space Defender HUD
- Create /src/views/space_defender_view.lua
- Implement HUD elements:
  - HP display (hearts or bar, top left)
  - Bomb count (bottom left)
  - Wave indicator (top center)
  - Boss HP bar (top center when boss active)
  - Score counter (top right)
  - "Bullets Active: X" counter (top right)
- Implement pause overlay
- Implement victory screen
- Implement game over screen
- Test HUD displays all info correctly

### 1.5.9 Level Completion & Bonuses
- Implement onLevelComplete() with:
  - Calculate token reward (base × multiplier)
  - Award tokens to player_data
  - Unlock next level
  - Apply level completion bonuses
- Define level bonuses:
  - Level 1: 2x token multiplier
  - Level 3: 2x token multiplier, 1.5x damage bonus
  - Level 5: 4x token multiplier, 2x damage, 2x fire rate
- Save game after completion
- Show victory screen with rewards
- Test bonuses apply correctly

---

## Phase 1.6: Automation System (Days 16-19)

### 1.6.1 VM Manager Model
- Create /src/models/vm_manager.lua
- Implement VMManager class with properties:
  - vm_slots (array of VM objects, **limited to 10 slots for MVP**)
  - total_tokens_per_minute (calculated)
- VM slot object:
  - slot_index
  - active (boolean)
  - assigned_game_id
  - time_remaining (until cycle complete)
  - cycle_time (total time per cycle)
  - auto_play_power (from formula with auto-play metrics)
  - tokens_per_cycle (from auto_play_power)
  - is_auto_completed (boolean, affects consistency)
- Implement methods:
  - initialize(player_data)
  - update(dt, player_data) - tick VMs, award tokens
  - assignGame(slot_index, game_id, game_data, player_data)
  - removeGame(slot_index)
  - purchaseVM(player_data)
  - getVMCost(current_count) - expensive, max 10 for MVP
  - calculateTokensPerMinute()
  - getOptimalGameForVM(game_list) - suggestion helper
- **Strategic VM limitation:** Only 10 slots creates meaningful choices
- Test VM scarcity encourages specialization

### 1.6.2 Auto-Play Performance Calculation
- For each game, define auto-play metrics (70-80% of typical best)
- Calculate auto-play power using same formula
- Auto-play power < manual best power
- Store auto-play power in VM assignment
- Test auto-play generates reasonable tokens

### 1.6.3 VM Manager State
- Create /src/states/vm_manager_state.lua
- Implement VMManagerState class with properties:
  - selected_slot (number or nil)
  - game_selection_open (boolean)
  - filtered_games (completed games only)
  - scroll_offset
- Implement methods:
  - enter()
  - update(dt) - call vm_manager:update()
  - draw() - render VM grid and UI
  - mousepressed(x, y, button)
  - openGameSelection(slot_index)
  - assignGameToSlot(game_id)
  - purchaseNewVM()
- Test VM assignment works

### 1.6.4 VM Manager View
- Create /src/views/vm_manager_view.lua
- Implement drawing functions:
  - drawVMSlot(x, y, slot, game_data) - shows:
    - Assigned game name
    - Progress bar (time remaining)
    - Auto-play power
    - Tokens per cycle
    - "Remove" button
    - Or "Empty - Assign Game" if inactive
  - drawGameSelectionModal(games, player_data)
  - drawTokensPerMinute(total_rate)
  - drawPurchaseVMButton(cost, can_afford)
- Test all VM UI elements render

### 1.6.5 VM Upgrades
- Implement CPU upgrade in player_data
- Implement Overclock upgrade in player_data
- Apply upgrades to VM cycle times and token rates
- Add upgrade purchase buttons to VM Manager UI
- Test upgrades affect VM performance

### 1.6.6 Background Processing
- Ensure vm_manager:update() runs continuously
- VMs generate tokens during:
  - Other minigames
  - Space Defender
  - Desktop/launcher navigation
- Test background generation works everywhere
- Test token counter updates globally

---

## Phase 1.7: Desktop/OS Layer (Days 19-21)

### 1.7.1 Desktop State
- Create /src/states/desktop_state.lua
- Implement DesktopState class with properties:
  - icons (desktop icon objects)
  - wallpaper (color or image)
  - taskbar_height
- Implement methods:
  - enter() - create icons
  - update(dt)
  - draw() - desktop, icons, taskbar
  - mousepressed(x, y, button)
  - launchProgram(program_name)
- Desktop icons:
  - My Computer (defer for post-MVP)
  - Game Collection → launcher_state
  - VM Manager → vm_manager_state
  - Space Defender → space_defender_state (level select)
  - **CheatEngine** → cheat_engine_state
  - Recycle Bin (defer for post-MVP)
- Test double-click to launch programs

### 1.7.2 Desktop Visual Style
- Implement Windows 98 aesthetic:
  - Teal/gray wallpaper
  - Desktop icons with labels
  - Taskbar at bottom
  - Start button (cosmetic for MVP)
  - System tray with clock
- Use placeholder graphics (colored rectangles)
- Test desktop renders correctly

### 1.7.3 Window Management (Basic)
- For MVP: full-screen state switching (no actual windows)
- Each program is a full-screen state
- ESC returns to desktop from any program
- Test navigation between programs

### 1.7.4 Taskbar
- Draw taskbar at bottom of screen
- Show start button (left)
- Show clock (right, HH:MM format)
- Show system tray icons (cosmetic)
- Update clock every minute
- Test taskbar always visible

---

## Phase 1.8: CheatEngine Program (Days 21-22)

### 1.8.1 CheatEngine State
- Create /src/states/cheat_engine_state.lua
- Implement CheatEngineState class
- Interface styled like game trainer (black background, green text, hacker aesthetic)
- Shows list of unlocked games
- For each game, show available cheats with token costs

### 1.8.2 Cheat System Implementation
- Create /src/models/cheat_system.lua
- Define cheat types:
  - **Speed Modifiers:** Slower enemies, bullet time (500-1000 tokens)
  - **Advantage Modifiers:** Extra life, shield, invincibility time (1000-2000 tokens)
  - **Performance Boosters:** Score multiplier, time extension (2000-5000 tokens)
  - **Aim Assist:** Auto-targeting, perfect accuracy (5000+ tokens)
- Cheats apply to NEXT playthrough of selected game
- Store active cheats in temporary state
- When launching game with cheats, apply modifiers
- Cheats consumed after one playthrough
- Track cheat usage in statistics

### 1.8.3 CheatEngine UI
- Draw window with edgy styling
- List games with checkboxes for available cheats
- Show token cost for each cheat
- Show "Apply Cheats & Launch Game" button
- Show fake cheats that don't work (part of joke):
  - "Infinite Lives" (does nothing)
  - "Unlock All Games" (fake)
  - "God Mode" (doesn't work)
- Add fake "cracked by" credits
- Test cheats apply correctly to next playthrough

### 1.8.4 Strategic Cheat Usage
- Test cheats make games noticeably easier
- Verify still requires playing the game (not instant win)
- Test trading tokens for easier high scores feels fair
- Test cheats are useful for difficult high-numbered clones
- Example use: "I'm stuck on SS50, buy Extra Life + Slower Enemies, try again"

---

## Phase 1.9: Integration & Game Controller (Days 22-23)

**[Renumbered from previous 1.8]**

### 1.8.1 Game Controller Setup
- Create /src/controllers/game_controller.lua
- Implement GameController class with properties:
  - player_data (PlayerData instance)
  - game_data (GameData instance)
  - vm_manager (VMManager instance)
  - bullet_system (BulletSystem instance)
  - state_machine (StateMachine instance)
- Implement methods:
  - init() - load save, initialize all systems, register states
  - update(dt) - update vm_manager, state_machine, auto-save
  - draw() - call state_machine:draw()
  - keypressed, mousepressed, etc. - forward to state_machine

### 1.8.2 State Registration
- Register all states with state_machine:
  - desktop_state
  - launcher_state
  - minigame_state
  - space_defender_state
  - vm_manager_state
- Pass game_controller reference to all states
- Test all states can access shared data

### 1.8.3 Save System Integration
- Implement auto-save every 30 seconds
- Save on:
  - Game unlock
  - Game completion
  - Level completion
  - VM assignment/removal
  - Upgrade purchase
- Test save/load cycle preserves all data
- Test game continues correctly after load

### 1.8.4 Token Flow Integration
- Verify tokens flow correctly:
  - Manual game completion → player_data
  - VM automation → player_data
  - Level completion → player_data
  - Purchases → deduct from player_data
- Apply token multipliers everywhere
- Test token counter updates in real-time

### 1.8.5 Power/Formula Integration
- Bullet system reads completed games
- Calculates power from performance formulas
- Applies level bonuses (fire rate, damage multipliers)
- Updates when:
  - Game completed with new best
  - Level completed (bonuses apply)
- Test bullet power reflects performance correctly
- Test improvements are noticeable in Space Defender

---

## Phase 1.10: Balance & Polish (Days 23-26)

**[Renumbered from previous 1.9]**

### 1.10.1 First Complete Playthrough
- Play from start to Level 5 completion
- Track time (target: 2-3 hours)
- Test skip-ahead strategy: try jumping to harder variants
- Note if difficulty prevents skipping (should require skill)
- Test auto-completion triggers and feels rewarding
- Note progression pacing
- Identify any grinding walls
- Record token flow rates
- Note power curve
- Test CheatEngine usage feels strategic

### 1.10.2 Formula Balancing
- Review all 5 game formulas
- Adjust multipliers for smooth progression within families
- Test exponential cost curve feels right (1x, 3x, 7x, 15x, 30x, 50x)
- Ensure formulas reward skill appropriately
- Verify baseline auto-completion is weaker but fair (60-70%)
- Test that replaying for better scores feels worthwhile
- Balance trash vs. mid tier power scaling
- Test high-difficulty clones can't be brute-forced

### 1.10.3 Economy Balancing
- Adjust unlock costs if too expensive/cheap (should create risk-reward)
- Test that unlocking high variant without skill = wasted tokens
- Tune token generation rates
- Adjust VM costs (should be limited resource)
- Verify multipliers create satisfying spikes
- Test auto-completion doesn't trivialize progression
- Ensure player always has clear next goal
- Test skip-ahead creates interesting decisions
- Test no excessive grinding required
- Balance CheatEngine costs vs benefits

### 1.9.4 Space Defender Balancing
- Adjust enemy HP for each level
- Tune boss HP for satisfying fights
- Test with different bullet counts:
  - Level 1: 5-10 bullets
  - Level 2: 15-25 bullets
  - Level 3: 30-50 bullets
  - Level 4: 60-100 bullets
  - Level 5: 120-150 bullets
- Verify difficulty curve
- Test level bonuses feel impactful

### 1.9.5 UI/UX Polish
- Review all UI screens for clarity
- Ensure formula displays are understandable
- Add tooltips where helpful
- Improve button hover/press states
- Add visual feedback for all actions
- Test UI is intuitive

### 1.9.6 Visual Effects (Basic)
- Add simple screen shake in Space Defender
- Add basic particle effects (explosions)
- Add flash effects on damage
- Add smooth fade transitions between states
- Keep effects simple for MVP
- Test effects don't hurt performance

### 1.9.7 Audio (Basic)
- Add placeholder sound effects:
  - Button clicks
  - Purchase success
  - Game completion
  - Bullet fire (quiet, doesn't stack annoyingly)
  - Enemy death
  - Boss death
  - Level complete
- Add placeholder music:
  - Desktop/Launcher (quiet ambient)
  - Space Defender (chiptune action)
- Implement volume controls in settings
- Test audio doesn't overlap poorly

---

## Phase 1.11: Testing & Bug Fixing (Days 26-28)

**[Renumbered from previous 1.10]**

### 1.11.1 Feature Testing
- Test all minigames complete correctly at all difficulty levels
- Test difficulty scaling works (harder games genuinely harder)
- Test all formulas calculate correctly
- Test auto-completion triggers correctly when beating high variants
- Test baseline performance is fair
- Test skip-ahead unlocking works
- Test risk-reward of expensive unlocks feels meaningful
- Test save/load works in all scenarios
- Test VM automation generates tokens
- Test Space Defender levels are beatable
- Test CheatEngine modifiers work correctly
- Test all UI elements are clickable
- Test ESC key works everywhere
- Test performance feedback is clear

### 1.11.2 Edge Case Testing
- Test with 0 tokens (can't unlock anything)
- Test with maximum tokens
- Test unlocking high-difficulty game first (should fail or barely succeed)
- Test auto-completion with only 1 game beaten in family
- Test auto-completion with all games beaten (no effect)
- Test with all games unlocked
- Test with 0 games unlocked
- Test with all 10 VMs running
- Test with 150+ bullets on screen
- Test rapid clicking/button mashing
- Test boundary conditions
- Test CheatEngine with no tokens
- Test CheatEngine on already-perfect scores

### 1.10.3 Performance Testing
- Test game runs at 60 FPS with 150 bullets
- Test for memory leaks (play for 30+ minutes)
- Profile performance bottlenecks
- Optimize if needed
- Test on minimum spec hardware if available

### 1.10.4 Save/Load Testing
- Save at various points
- Close and reload game
- Verify all data restored
- Test save corruption handling
- Test with no save file
- Test save file is valid JSON

### 1.10.5 Bug Documentation
- Create bug list
- Prioritize: Critical > High > Medium > Low
- Fix all critical bugs (crashes, progression blockers)
- Fix all high priority bugs (major gameplay issues)
- Address medium priority bugs if time allows
- Document known low priority bugs

### 1.10.6 Second Playthrough
- Complete fresh playthrough after bug fixes
- Verify all fixes work
- Confirm target playtime (2-3 hours)
- Ensure progression is smooth
- Verify formulas are clear
- Confirm game is fun

---

## Phase 1.11: MVP Finalization (Days 28-30)

### 1.11.1 Content Completion
- Finalize all game descriptions
- Write boss names for 5 levels
- Write level names
- Create tutorial text
- Write error messages
- Proofread all text

### 1.11.2 Asset Finalization
- Create or source placeholder sprites:
  - Desktop icons (32x32)
  - Game thumbnails (64x64)
  - Player ship (40x40)
  - Enemies (32x32, 5 types)
  - Bosses (64x64, 5 types)
  - Bullets (8x8, various colors)
- Ensure consistent art style
- Test all sprites load correctly

### 1.11.3 Settings Menu
- Create /src/states/settings_state.lua
- Implement settings options:
  - Graphics (resolution, fullscreen, particles)
  - Audio (master, music, SFX volumes)
  - Gameplay (difficulty assists if needed)
- Save settings to separate file
- Load settings on startup
- Test settings persist

### 1.11.4 Tutorial System
- Implement simple helper on first launch
- Tutorial steps:
  - "Double-click Game Collection to start"
  - "Unlock a game to play it"
  - "Your performance determines bullet power"
  - "Use VM Manager to automate games"
  - "Play Space Defender to progress"
- Make helper dismissible
- Option to disable in settings
- Test tutorial guides new players

### 1.11.5 Statistics Tracking
- Create /src/models/statistics.lua
- Track basic stats:
  - Total games unlocked
  - Total bullets fired
  - Total tokens earned
  - Total playtime
  - Highest damage single hit
- Create statistics screen
- Display stats in formatted list
- Test stats update correctly

### 1.11.6 Completion Screen
- Create special screen after Level 5
- Show:
  - "MVP COMPLETE!"
  - Final statistics
  - Playtime
  - Thank you message
- Options:
  - Continue Playing
  - View Statistics
  - Quit
- Test completion screen appears

### 1.11.7 Build Creation
- Create Windows build (.exe with bundled runtime)
- Test build on clean Windows machine
- Verify save file location is correct
- Test build runs without Love2D installed
- Document any build issues

### 1.11.8 Documentation
- Write README.md:
  - Game description
  - Controls
  - How to play
  - Formula system explanation
- Write known issues list
- Create basic troubleshooting guide

### 1.11.9 Final Testing
- Complete final playthrough on build
- Test all features work in build
- Verify performance is acceptable
- Check for any remaining critical bugs
- Confirm MVP is ready for feedback

---

## MVP Completion Checklist

### Core Systems
- [ ] Player data model with all properties
- [ ] Game data model with formula system
- [ ] 5 unique minigames with working formulas
- [ ] Clone generation creating 200+ games
- [ ] Performance tracking per game
- [ ] Save/load system working reliably
- [ ] State machine managing all states

### Minigame System
- [ ] Base game class with formula support
- [ ] 5 playable minigames (30 sec - 2 min each)
- [ ] Performance metrics tracked correctly
- [ ] Formula calculations working
- [ ] Performance affects bullet power visibly
- [ ] Completion screen shows results clearly
- [ ] Can replay for better scores

### Space Defender
- [ ] 5 levels with waves and bosses
- [ ] Player ship with controls
- [ ] Bullet system integrated with formulas
- [ ] Bullet power reflects game performance
- [ ] Enemies with HP scaling
- [ ] 5 unique bosses
- [ ] Level completion bonuses apply
- [ ] HUD shows all necessary info
- [ ] Runs at 60 FPS with 150+ bullets

### Automation
- [ ] VM Manager with slot system
- [ ] Auto-play performance calculation working
- [ ] VMs generate tokens based on formulas
- [ ] Background token generation during all activities
- [ ] Can assign/remove games from VMs
- [ ] Can purchase additional VMs
- [ ] CPU and Overclock upgrades functional
- [ ] Total tokens/minute displayed

### Game Launcher
- [ ] Browse games by category
- [ ] Formula display for all games
- [ ] Shows current performance and power
- [ ] Shows auto-play power estimate
- [ ] Token generation rate visible
- [ ] Can unlock games with tokens
- [ ] Can launch unlocked games
- [ ] Can see best performance records
- [ ] Locked games show cost

### Desktop/OS
- [ ] Desktop with icons and wallpaper
- [ ] Taskbar with clock
- [ ] Icons launch correct programs
- [ ] Double-click detection works
- [ ] Windows 98 aesthetic
- [ ] Can navigate between all programs
- [ ] ESC returns to desktop

### Token Economy
- [ ] Manual completion awards tokens
- [ ] VM automation generates tokens
- [ ] Level completion rewards tokens
- [ ] Token multipliers apply correctly
- [ ] Can purchase games with tokens
- [ ] Can purchase VMs with tokens
- [ ] Can purchase upgrades with tokens
- [ ] Token counter updates everywhere

### Progression
- [ ] Clear progression from Level 1-5
- [ ] Formula system is understandable
- [ ] Performance improvements feel impactful
- [ ] Optimization is rewarding
- [ ] No grinding walls
- [ ] Completable in 2-3 hours
- [ ] Level bonuses apply correctly
- [ ] Bullet power scales with performance

### UI/UX
- [ ] All buttons work
- [ ] All screens are navigable
- [ ] Formula displays are clear
- [ ] Performance feedback is visible
- [ ] Tooltips where helpful
- [ ] Hover states work
- [ ] Visual feedback for actions
- [ ] Settings menu functional
- [ ] Tutorial guides new players

### Polish
- [ ] Basic sound effects
- [ ] Basic music
- [ ] Simple screen shake
- [ ] Basic particle effects
- [ ] Smooth transitions
- [ ] Windows 98 style consistent
- [ ] No placeholder text remains
- [ ] All assets load correctly

### Technical
- [ ] Runs at 60 FPS with 150+ bullets
- [ ] No crashes during normal play
- [ ] Save system works reliably
- [ ] No memory leaks
- [ ] Performance is acceptable
- [ ] Build runs without Love2D

### Testing
- [ ] Full playthrough completed
- [ ] All features tested
- [ ] Edge cases tested
- [ ] Save/load tested thoroughly
- [ ] No critical bugs remain
- [ ] Known issues documented

### Release Ready
- [ ] Windows build created
- [ ] Build tested on clean machine
- [ ] README written
- [ ] Controls documented
- [ ] Known issues listed
- [ ] Formula system explained

---

## Development Best Practices for MVP

### Code Organization
- Use MVC architecture strictly
- Keep models pure (no rendering)
- Keep views pure (no logic)
- Controllers coordinate between models and views
- One class per file
- Clear, descriptive names

### Performance Considerations
- Object pooling for bullets
- Avoid creating tables every frame
- Cache calculated values
- Profile early and often
- Test with max bullet count frequently

### Formula Design Guidelines
- Formulas should be simple enough to understand
- All metrics should be trackable and visible
- Better performance should always mean more power
- Auto-play should be consistently weaker (70-80%)
- Formulas should reward optimization, not perfection
- Display formulas clearly in UI

### Testing Strategy
- Test each feature immediately after implementation
- Test integration between systems frequently
- Complete full playthroughs regularly
- Test edge cases (0 values, max values)
- Save/load test after any data structure change
- Performance test with max bullets frequently

### Version Control
- Commit frequently with clear messages
- Commit after each completed feature
- Tag major milestones (each phase complete)
- Keep working builds on main branch
- Use branches for experimental features

### Time Management
- Focus on core features first
- Avoid perfectionism during MVP
- Placeholder assets are fine
- Polish comes after functionality
- Don't add features beyond MVP scope
- Track time to stay on schedule

---

## Common Pitfalls to Avoid

### Scope Creep
- **Don't:** Add "just one more" game type
- **Don't:** Implement full OS features in MVP
- **Don't:** Perfect the art before mechanics work
- **Do:** Stick to 5 game templates for MVP
- **Do:** Use placeholders for non-critical assets
- **Do:** Focus on proving the core loop

### Over-Engineering
- **Don't:** Build complex systems for future features
- **Don't:** Abstract everything prematurely
- **Do:** Build what's needed for MVP
- **Do:** Refactor when patterns emerge
- **Do:** Keep code simple and readable

### Under-Testing
- **Don't:** Skip testing until the end
- **Don't:** Assume features work
- **Do:** Test each feature immediately
- **Do:** Complete regular playthroughs
- **Do:** Test save/load constantly

### Formula Complexity
- **Don't:** Make formulas too complicated
- **Don't:** Hide what metrics matter
- **Don't:** Make perfect scores required
- **Do:** Keep formulas transparent
- **Do:** Reward skill but allow mistakes
- **Do:** Display formulas clearly

### Performance Issues
- **Don't:** Ignore performance until the end
- **Don't:** Create objects every frame
- **Do:** Profile early with max bullets
- **Do:** Implement object pooling from start
- **Do:** Test on lower-end hardware

---

## Transitioning from MVP to Full Development

### MVP Success Indicators
If MVP achieves these, proceed to full development:
- Core loop is fun and engaging
- Formula system is clear and motivating
- Players want more content
- Performance is stable
- No critical bugs remain
- Feedback is positive on concept

### What Changes in Full Development
**Content Expansion (Phase 2):**
- Expand from 5 to 20 Space Defender levels
- Expand from 5 to 20-25 unique minigame templates
- Expand from 200 to 1000 total games
- More complex formulas for advanced games
- Additional upgrade types

**Feature Expansion (Phases 3-4):**
- Full OS experience with all programs
- Fake website for shopping
- More Easter eggs and secrets
- Additional automation options
- More visual and audio polish

**Polish Expansion (Phases 5-6):**
- Professional art and audio
- Rich particle effects
- Smooth animations everywhere
- Achievement system
- Statistics and leaderboards

### What Stays the Same
- Core architecture (MVC)
- Formula system design
- Performance-based progression
- Automation mechanics
- Token economy structure
- Save system
- Windows 98 aesthetic

### Architecture Considerations
MVP architecture should support:
- Easy addition of new minigame templates
- Simple formula modifications
- Straightforward level additions
- Modular UI components
- Extensible upgrade system

If these are architected well in MVP, full development flows naturally from Phase 1 into Phase 2.

---

## MVP Daily Schedule Example

### Week 1 (Days 1-5)
**Day 1:** Project setup, libraries, state machine  
**Day 2:** Player data model, game data model  
**Day 3:** Formula system, save manager  
**Day 4:** Base game class, minigame state  
**Day 5:** First minigame template (space shooter)

### Week 2 (Days 6-10)
**Day 6:** Second minigame template  
**Day 7:** Third and fourth minigame templates  
**Day 8:** Fifth minigame template, clone generation  
**Day 9:** Launcher state structure  
**Day 10:** Launcher view, formula display

### Week 3 (Days 11-15)
**Day 11:** Space Defender state setup  
**Day 12:** Player ship, basic controls, bullet system  
**Day 13:** Enemy system, wave system  
**Day 14:** Boss system, collision detection  
**Day 15:** Space Defender HUD, level completion

### Week 4 (Days 16-20)
**Day 16:** VM Manager model  
**Day 17:** Auto-play calculation, VM state  
**Day 18:** VM Manager view, upgrades  
**Day 19:** Desktop state, basic OS layer  
**Day 20:** Game controller integration

### Week 5 (Days 21-25)
**Day 21:** State registration, save integration  
**Day 22:** First complete playthrough, notes  
**Day 23:** Formula balancing  
**Day 24:** Economy balancing  
**Day 25:** Space Defender balancing

### Week 6 (Days 26-30)
**Day 26:** UI/UX polish, basic effects  
**Day 27:** Feature testing, edge cases  
**Day 28:** Bug fixing, second playthrough  
**Day 29:** Content finalization, settings, tutorial  
**Day 30:** Build creation, documentation, final testing

**Adjust based on:**
- Your available hours per day
- Your experience with Love2D
- Complexity of chosen minigames
- How much polish you want in MVP

---

## Key Milestones & Validation Points

### Milestone 1 (Day 5): First Playable Game
**Validation:**
- Can play one minigame start to finish
- Performance metrics are tracked
- Formula calculates power correctly
- Completion screen shows results

**If not working:** Focus on getting one game fully functional before adding more.

### Milestone 2 (Day 10): Full Minigame Suite
**Validation:**
- All 5 games are playable
- Clone system generates 200+ games
- Launcher displays all games with formulas
- Can unlock and play any game

**If not working:** Simplify game mechanics or reduce clone count.

### Milestone 3 (Day 15): Space Defender Playable
**Validation:**
- Level 1 is completable
- Bullets spawn based on unlocked games
- Bullet power reflects performance
- Can see impact of better performance

**If not working:** Simplify level design or reduce enemy HP.

### Milestone 4 (Day 20): Full Loop Connected
**Validation:**
- Can play minigames → unlock bullets → play Space Defender
- VM automation works and generates tokens
- All states are connected and navigable
- Save/load preserves all progress

**If not working:** Focus on integration bugs before adding features.

### Milestone 5 (Day 25): Balanced and Polished
**Validation:**
- Complete playthrough in 2-3 hours
- Progression feels smooth
- No grinding walls
- Formula system is clear

**If not working:** Iterate on balance before finalizing.

### Milestone 6 (Day 30): MVP Complete
**Validation:**
- All features work
- No critical bugs
- Build runs on clean system
- Ready for feedback

**If not working:** Extend MVP timeline or cut non-essential features.

---

## Resource Management

### Asset Needs for MVP
**Essential (Must Have):**
- 5 game icon sprites (can be simple)
- Player ship sprite
- 5 enemy type sprites
- 5 boss sprites
- Bullet sprites (5-10 colors)
- UI elements (buttons, windows)
- Desktop icons

**Nice to Have:**
- Particle sprites
- Background images
- Additional UI decorations

**Source:**
- Free: Kenney.nl, OpenGameArt.org
- Make your own: MS Paint, simple pixel art
- Placeholder: Colored rectangles work fine for MVP

### Sound Needs for MVP
**Essential:**
- Button click
- Game completion
- Enemy death
- Level complete

**Nice to Have:**
- Bullet fire sounds
- Boss explosion
- Background music
- UI sounds

**Source:**
- Free: Freesound.org
- Generate: BFXR/SFXR
- Placeholder: Silence is acceptable for MVP

### Time Allocation
**Critical Path (70% of time):**
- Core systems (models, controllers)
- Minigame implementation
- Space Defender
- Integration and testing

**Important (20% of time):**
- UI/UX
- Balancing
- Bug fixing
- Polish

**Optional (10% of time):**
- Extra polish
- Additional features
- Perfect assets
- Over-optimization

---

## Success Criteria Summary

### MVP is successful if:
1. **Formula system works and is clear** - Players understand performance → power
2. **Core loop is engaging** - Playing games to improve power is fun
3. **Progression is smooth** - No grinding walls, 2-3 hours to complete
4. **Technical stability** - No crashes, saves work, 60 FPS maintained
5. **Demonstrates full concept** - Proves the game idea has merit

### MVP is ready for full development if:
1. **Positive feedback on core mechanics**
2. **Players want more content**
3. **Formula system is validated**
4. **Technical foundation is solid**
5. **No fundamental design flaws**

### MVP should NOT:
1. Have perfect art/audio (placeholders are fine)
2. Include all planned features (that's full development)
3. Be perfectly balanced (good enough for MVP)
4. Have zero bugs (just no critical bugs)
5. Be marketing-ready (it's for validation)

---

## Post-MVP Next Steps

### Immediate Actions After MVP
1. **Gather feedback** from playtesters
2. **Analyze playtime data** and progression
3. **Identify pain points** in formula system
4. **Review balance** based on feedback
5. **Prioritize improvements** for Phase 2

### Deciding on Full Development
**Proceed if:**
- Core concept is validated
- Players enjoyed the experience
- Formula system works well
- Technical foundation is solid
- You're excited to continue

**Reconsider if:**
- Formula system is confusing
- Optimization feels tedious
- Technical issues are severe
- Core loop isn't fun
- Feedback is negative

### Transitioning to Phase 2
- **Review MVP lessons learned**
- **Refactor if needed** based on learnings
- **Plan content expansion** (15 more minigames)
- **Expand Space Defender** (15 more levels)
- **Begin Phase 2** seamlessly from MVP foundation

The MVP is designed to flow directly into Phase 2 without requiring major architectural changes. Good MVP architecture supports smooth expansion.

### Core Systems
- [ ] Player data model with all properties including auto-completion tracking
- [ ] Game data model with formula system and difficulty scaling
- [ ] 5 unique minigames with working formulas and progressive difficulty
- [ ] Clone generation creating 200+ games with difficulty tiers
- [ ] Auto-completion system for skipped games
- [ ] Performance tracking per game (manual and auto-completed)
- [ ] Skip-ahead unlock system with cost-gating
- [ ] Save/load system working reliably
- [ ] State machine managing all states
- [ ] CheatEngine program functional

### Minigame System
- [ ] Base game class with formula support and difficulty modifiers
- [ ] 5 playable minigames (30 sec - 2 min each)
- [ ] Difficulty scaling works (high clones genuinely harder)
- [ ] Performance metrics tracked correctly
- [ ] Formula calculations working
- [ ] Performance affects bullet power visibly
- [ ] Completion screen shows results and auto-completion triggers
- [ ] Can replay for better scores
- [ ] Can use CheatEngine for strategic advantage

### Space Defender
- [ ] 5 levels with waves and bosses
- [ ] Player ship with controls
- [ ] Bullet system integrated with formulas
- [ ] Bullet power reflects game performance (manual and auto-completed)
- [ ] Enemies with HP scaling
- [ ] 5 unique bosses
- [ ] Level completion bonuses apply
- [ ] HUD shows all necessary info
- [ ] Runs at 60 FPS with 150+ bullets

### Automation
- [ ] VM Manager with slot system (max 10 slots)
- [ ] Auto-play performance calculation working
- [ ] VMs generate tokens based on formulas
- [ ] Background token generation during all activities
- [ ] Can assign/remove games from VMs
- [ ] Can purchase additional VMs (expensive, limited)
- [ ] CPU and Overclock upgrades functional
- [ ] Total tokens/minute displayed
- [ ] Limited slots create strategic choices

### Game Launcher
- [ ] Browse games by category and difficulty
- [ ] Formula display for all games
- [ ] Shows current performance and power
- [ ] Shows auto-completed vs manually completed status
- [ ] Shows difficulty indicators
- [ ] Shows auto-play power estimate
- [ ] Token generation rate visible
- [ ] Can unlock games with tokens (skip-ahead enabled)
- [ ] Can launch unlocked games
- [ ] Can see best performance records
- [ ] Locked games show cost and risk assessment
- [ ] Risk-reward decisions feel meaningful

### Skip-Ahead & Auto-Completion
- [ ] Can unlock any game in available tier (cost-gated)
- [ ] Higher difficulty games cost more tokens
- [ ] Completing high-numbered game triggers auto-completion
- [ ] Lower games auto-complete with baseline performance
- [ ] Baseline performance is fair (60-70% of strong play)
- [ ] Auto-completed games show special indicator
- [ ] Can replay auto-completed games for better scores
- [ ] Auto-completion celebration is clear and exciting
- [ ] System respects player time (no forced grinding)

### Desktop/OS
- [ ] Desktop with icons and wallpaper
- [ ] Taskbar with clock
- [ ] Icons launch correct programs
- [ ] Double-click detection works
- [ ] Windows 98 aesthetic
- [ ] Can navigate between all programs
- [ ] CheatEngine program accessible
- [ ] ESC returns to desktop

### CheatEngine
- [ ] Lists unlocked games
- [ ] Shows available cheats with token costs
- [ ] Can purchase cheats for next playthrough
- [ ] Cheats apply correctly (game becomes easier)
- [ ] Cheats consumed after use
- [ ] Still requires playing the game (not instant win)
- [ ] Fake cheats don't work (part of joke)
- [ ] Hacker aesthetic styling
- [ ] Strategic resource management

### Token Economy
- [ ] Manual completion awards tokens based on formula
- [ ] VM automation generates tokens based on formula
- [ ] Level completion rewards tokens
- [ ] Token multipliers apply correctly
- [ ] Can purchase games with tokens (exponential costs)
- [ ] Can purchase VMs with tokens
- [ ] Can purchase upgrades with tokens
- [ ] Can purchase cheats with tokens
- [ ] Token counter updates everywhere
- [ ] Auto-completion affects token generation fairly

### Progression
- [ ] Clear progression from Level 1-5
- [ ] Formula system is understandable
- [ ] Skip-ahead system is intuitive
- [ ] Auto-completion feels earned and rewarding
- [ ] Performance improvements feel impactful
- [ ] Optimization is rewarding not tedious
- [ ] Risk-reward decisions are engaging
- [ ] No grinding walls
- [ ] Can't brute-force high difficulties without skill
- [ ] Completable in 2-3 hours
- [ ] Level bonuses apply correctly
- [ ] Bullet power scales with performance
- [ ] Multiple viable strategies exist

### UI/UX
- [ ] All buttons work
- [ ] All screens are navigable
- [ ] Formula displays are clear
- [ ] Difficulty indicators are visible
- [ ] Auto-completion status is clear
- [ ] Performance feedback is visible
- [ ] Tooltips where helpful
- [ ] Hover states work
- [ ] Visual feedback for actions
- [ ] Risk warnings for expensive unlocks
- [ ] Settings menu functional
- [ ] Tutorial guides new players through complex systems

### Polish
- [ ] Basic sound effects
- [ ] Basic music
- [ ] Simple screen shake
- [ ] Basic particle effects
- [ ] Smooth transitions
- [ ] Auto-completion celebration effects
- [ ] Windows 98 style consistent
- [ ] No placeholder text remains
- [ ] All assets load correctly
- [ ] CheatEngine styling is authentic

### Technical
- [ ] Runs at 60 FPS with 150+ bullets
- [ ] No crashes during normal play
- [ ] Save system preserves auto-completion state
- [ ] No memory leaks
- [ ] Performance is acceptable
- [ ] Build runs without Love2D
- [ ] Difficulty scaling performs well

### Testing
- [ ] Full playthrough completed (including skip-ahead strategy)
- [ ] All features tested
- [ ] Skip-ahead and auto-completion tested thoroughly
- [ ] Difficulty scaling prevents easy wins
- [ ] CheatEngine tested for all games
- [ ] Edge cases tested (skip to highest, auto-complete all, etc.)
- [ ] Save/load tested thoroughly (auto-completion persists)
- [ ] No critical bugs remain
- [ ] Known issues documented

### Release Ready
- [ ] Windows build created
- [ ] Build tested on clean machine
- [ ] README written (explains skip-ahead and formulas)
- [ ] Controls documented
- [ ] Known issues listed
- [ ] Formula system explained
- [ ] Skip-ahead system explained
- [ ] Auto-completion system explained

---

## Key MVP Success Metrics

### The system works if:
1. **Skip-ahead creates meaningful decisions** - "Can I handle #20 or should I start at #10?"
2. **Auto-completion feels rewarding** - "I beat SS50, got 49 games for free!"
3. **Difficulty gating works** - Can't just buy SS50 and win without skill
4. **Formulas are transparent** - Always understand performance → power
5. **Multiple strategies viable** - Can specialize or generalize
6. **No forced grinding** - Don't need to play all 50 variants
7. **CheatEngine adds depth** - Strategic use of tokens for easier scores
8. **Limited VMs matter** - Which 10 games to automate is important choice
9. **Progression is smooth** - 2-3 hours, no walls
10. **System respects time** - Beating hard variant feels efficient, not punishing

### Red flags to watch for:
- Players confused by skip-ahead (need better tutorial)
- Auto-completion feels cheap or unearned (adjust baseline)
- High difficulties too easy (need harder scaling)
- High difficulties too hard (frustrating, not challenging)
- Skip-ahead removes all challenge (costs too low)
- Grinding through all 50 feels necessary (auto-completion too weak)
- CheatEngine feels required vs. optional (balance issue)
- VM limit feels arbitrary vs. strategic (need clear value proposition)

---

## Post-MVP Validation Questions

Ask playtesters:

**About Skip-Ahead:**
- Did you understand you could skip to harder games?
- Did you try jumping ahead? What happened?
- Did the cost-risk feel fair?
- Did you go back to easier games to learn?

**About Auto-Completion:**
- Did you understand when auto-completion triggered?
- Did it feel fair or cheap?
- Did you replay any auto-completed games for better scores?
- Was it clear which games were auto-completed vs manual?

**About Difficulty:**
- Could you tell that higher-numbered games were harder?
- Did you hit a difficulty wall? What did you do?
- Did any game feel impossible?
- Did any game feel too easy for its multiplier?

**About Formulas:**
- Did you understand the formulas?
- Did you try to optimize your performance?
- Which metrics did you focus on?
- Did better performance feel impactful?

**About CheatEngine:**
- Did you use CheatEngine?
- When and why?
- Did it feel fair or like cheating?
- Did it help you progress?

**About VMs:**
- How many VMs did you have by the end?
- Which games did you assign to VMs?
- Did you feel limited by 10 slots?
- How did you decide which games to automate?

**About Overall Experience:**
- How long did it take to beat Level 5?
- Did you feel like you had to grind?
- What was the most fun part?
- What was the most frustrating part?
- Would you want to play more levels?

---

## Example Player Journey (Ideal)

**Minute 1-5: Discovery**
- Launch game, see desktop
- Open Game Collection
- See 200+ games, feel overwhelmed
- Filter by Action → see Space Shooter 1-40
- Read formula: (Kills - Deaths) × Multiplier
- Think: "Okay, I understand this"

**Minute 5-15: First Attempts**
- See SS1 costs 100 tokens (I have 500)
- Try SS1: Easy, win, get 50 power
- Think: "Can I skip ahead?"
- Try SS10: Hard! Barely win, get 350 power
- Think: "Wow, big reward but risky"
- Try SS20: Get destroyed, lose 5,000 tokens
- Think: "Too hard, learned my lesson"

**Minute 15-30: Finding Level**
- Try SS15: Comfortable win
- **Auto-completion triggers: SS1-14 completed!**
- Think: "Whoa! I just got 14 games for free!"
- See total power from family: ~3,000
- Feel powerful in Space Defender

**Minute 30-60: Strategy Emerges**
- Try other game families at ~15 difficulty
- Find I'm good at Dodge games too
- Bad at Memory games (skip entirely)
- Specialize in Shooters and Dodge
- Build VM automation with best games

**Hour 1-2: Optimization**
- Push for SS30, use CheatEngine to help
- Beat it, get SS16-29 auto-completed
- Massive power spike
- Start farming tokens with VMs
- Try optimizing a few key games manually

**Hour 2-3: Victory**
- Finally beat SS50 with practice
- **SS31-49 auto-complete**
- Total Shooter family power: huge
- Beat Level 5 with bullet storm
- Think: "That was satisfying, not grindy"
- Want more content (good sign for full game)

**Total Space Shooters played: ~8 out of 50**
**Time on Space Shooters: ~45 minutes**
**Felt: Strategic, skill-based, rewarding, efficient**

---

## Transition to Full Development

**If MVP succeeds, Phase 2 adds:**
- 15 more Space Defender levels (6-20)
- 15-20 more unique minigame templates
- Expansion to 1000 total games
- More game archetypes (RNG, deterministic, unfair)
- Full OS programs
- Fake website
- More Easter eggs
- Polish everything

**Architecture is ready for expansion:**
- Formula system supports unlimited games
- Skip-ahead works with any number of clones
- Auto-completion scales to larger families
- Difficulty system supports more variants
- CheatEngine supports any game
- VM system can expand if needed

**The core innovation is proven:**
- Performance-based formulas work
- Skip-ahead respects player time
- Auto-completion feels fair
- Difficulty gating prevents exploits
- Multiple strategies are viable
- System creates engaging optimization puzzle

Ready to build!### 1.2.2 Game Data Model
- Create /src/models/game_data.lua
- Implement GameData class
- Define game object structure:
  - id (unique identifier)
  - display_name
  - game_class (class name to instantiate)
  - tier (trash/mid/premium)
  - category (action/puzzle/sports/etc)
  - difficulty_level (1-50, determines actual difficulty)
  - unlock_cost (tokens, exponential scaling)
  - formula_string (human-readable formula)
  - formula_function (actual calculation function)
  - metrics_tracked (array of metric names)
  - auto_play_performance (table of typical auto-play metrics)
  - baseline_completion_performance (for auto-completion of skipped games)
  - bullet_fire_rate (shots per second)
  - bullet_sprite (sprite identifier)
  - bullet_special (special property if any)
  - thumbnail (sprite identifier)
  - variant_of (base game ID if clone)
  - variant_multiplier (multiplier for clone)
- Implement methods:
  - loadGames() (hardcoded for MVP)
  - getGame(game_id)
  - getAllGames()
  - getGamesByCategory(category)
  - getGamesByTier(tier)
  - generateClones(base_game_id, count, multipliers, difficulty_scaling)
  - calculatePower(game_id, metrics)
  - calculateTokenRate(game_id, metrics)
  - getBaselinePerformance(game_id) - for auto-completion# MVP Development Plan: "10,000 Games Collection"
## Phase 1: Foundation (30 Days Detailed Action Plan)

---

