Phased Action Plan: Interactive Desktop & Window Management System
Overview
Transform the desktop into a fully interactive Windows 98-style environment with windowing, file management, and icon manipulation. Each phase is independently testable and builds upon previous phases.

Phase 1: Core Data Models (Days 1-2)
Goal
Establish the foundational data structures and business logic without any UI changes.
Deliverables
Window Manager Model

Central registry tracking all open window instances
Window lifecycle management (creation, focus, minimize, maximize, close)
Z-order management for overlapping windows
Window state persistence (positions, sizes, minimized state)
Integration point for taskbar updates
Must handle multiple windows of same type (e.g., two file explorers)

Desktop Icon Model

Track custom icon positions per program_id
Mark icons as deleted (hidden from desktop, still in start menu)
Persist layout changes across sessions
Validate positions within desktop bounds
Provide default grid layout for unchanged icons

File System Model

Virtual filesystem structure (folders and files)
Navigation state (current directory path)
File/folder metadata (type, icon, associated program)
Define special folders: My Computer, Desktop, Recycle Bin
Action resolution (what happens when you open X)

Recycle Bin Model

Store deleted desktop items with metadata (original position, timestamp)
Restore functionality (moves back to desktop)
Empty functionality (permanently marks as deleted)
Integration with Desktop Icon Model

Testing Criteria

Can create, retrieve, and modify window records without UI
Icon positions save and load correctly from JSON
Virtual filesystem can be navigated programmatically
Recycle bin can store, retrieve, and restore items
All models handle missing/corrupted save data gracefully

Best Practices

Models must be UI-agnostic (no love.graphics calls)
Use dependency injection (no global state assumptions)
All persistence uses pcall with fallback to defaults
Externalize filesystem structure to JSON data file


Phase 2: Window System Foundation (Days 3-5)
Goal
Implement the core windowing system with rendering, dragging, and basic controls.
Deliverables
Window Base View Component

Reusable window chrome renderer (title bar, borders, buttons)
Support for standard window states (normal, maximized, minimized)
Draw order respecting z-index
Visual focus indicator (active vs inactive windows)
Window button rendering (minimize, maximize/restore, close)

Window Controller/Coordinator

Routes input events to appropriate window
Handles window dragging (title bar interaction)
Handles window resizing (drag border edges/corners)
Manages focus switching on click
Coordinates between Window Manager model and rendering
Enforces window bounds (can't drag off-screen completely)
Handles window control button clicks (min/max/close)

State Adaptation Layer

Modify existing states to render within a window bounds instead of fullscreen
States receive viewport parameters (x, y, width, height)
States handle clipped rendering (content stays within window)
Input coordinates translated to window-relative positions

Initial Window Integration

Convert one existing state (e.g., Settings) to windowed mode as proof-of-concept
Test window can be opened, moved, resized, minimized, maximized, closed
Verify state continues to function correctly within window bounds

Testing Criteria

Can open a windowed version of Settings from desktop
Window can be dragged by title bar
Window can be resized by dragging edges
Minimize/maximize/close buttons work correctly
Multiple windows can exist simultaneously
Clicking a window brings it to front
Window content renders correctly at different sizes
Window cannot be dragged entirely off-screen

Best Practices

Window chrome component should be stateless (pure rendering)
Controller checks window bounds before applying position changes
Use hit-testing helper functions (is point in title bar? on resize edge?)
Clamp window size to minimum (e.g., 200x150) and maximum (screen size)
Store original window size when maximizing (for restore)


Phase 3: Taskbar Integration (Days 6-7)
Goal
Extend taskbar to display and manage open windows.
Deliverables
Taskbar Window List

Display buttons for all open windows (from Window Manager)
Visual indication of active/focused window
Visual indication of minimized windows
Button resizing logic when many windows open (compress width)
Support reordering based on window creation order

Taskbar Interaction

Click taskbar button to focus/restore window
Click active window's button to minimize it
Right-click menu (optional: close, minimize, maximize)
Show window title text (truncated if needed)
Show window icon (from program data)

Window-Taskbar Synchronization

Taskbar updates when window opens
Taskbar updates when window closes
Taskbar updates when window focus changes
Taskbar updates when window title changes
Minimized windows stay in taskbar but marked differently

Testing Criteria

Open 3+ windows, verify all appear in taskbar
Click taskbar button switches to that window
Close a window, verify it disappears from taskbar
Minimize a window, verify taskbar shows minimized state
Open 10+ windows, verify taskbar buttons resize appropriately
Focused window clearly indicated in taskbar

Best Practices

Taskbar queries Window Manager for current state (don't duplicate data)
Calculate button widths dynamically based on window count
Use truncation (ellipsis) for long window titles
Taskbar buttons ordered by window creation time (stable order)


Phase 4: Convert Existing States to Windowed (Days 8-10)
Goal
Migrate all major states to open as windows instead of fullscreen takeovers.
Deliverables
Windowed State Conversions

Launcher State → opens in window
VM Manager State → opens in window
Space Defender State → opens in window (with option to maximize)
CheatEngine State → opens in window
Statistics State → opens in window
Settings State → already done in Phase 2
Debug Menu → opens in window (or remains overlay)

Desktop Launch Integration

Double-clicking desktop icon opens corresponding window
Program Registry extended with window metadata (default size, resizable?)
Running program check (some programs single-instance, others allow multiple)
Start menu launches windows
Run dialog launches windows

Window State Management

Each window type maintains its own state instance
States properly initialize when window opens
States properly cleanup when window closes
Save/load system preserves open windows on game restart (optional)

Testing Criteria

Can open any program from desktop/start menu as window
Each program displays correctly within window bounds
Can have Launcher + VM Manager + Settings open simultaneously
Space Defender works in windowed mode (critical: input + rendering)
Closing window properly cleans up state
ESC key no longer exits game (closes active window instead)

Best Practices

States should not assume fullscreen (use provided viewport)
Input handling must account for window-relative coordinates
States should not directly call love.graphics.clear() (window handles it)
Each state should define default window size in Program Registry
Heavy states (games) should indicate they prefer maximized on launch


Phase 5: File Explorer Implementation (Days 11-13)
Goal
Create a functional file explorer that can browse the virtual filesystem.
Deliverables
File Explorer State

Navigation interface (address bar, back/forward/up buttons)
File/folder list view (icons + names)
Support for multiple explorer windows (different directories)
Double-click to open folders or execute files
Right-click context menu (optional: rename, delete, properties)

File Explorer View

Toolbar area (navigation buttons, address bar)
Content area (scrollable list of items)
Status bar (item count, current selection)
Icon size options (large/small icons, list view)
Sorting options (name, type, date, size)

Filesystem Integration

Load virtual filesystem from JSON data file
Define contents of My Computer (Desktop shortcut, fake drives, etc.)
Define Desktop folder (shows current desktop icons)
Define Recycle Bin folder (shows deleted items)
Text files can be opened (show text content in window)

Program Launching from Explorer

Executable files (.exe) launch corresponding program
Special file types open with appropriate handler
Desktop shortcuts can point to programs or locations
Properties dialog shows file metadata (optional)

Testing Criteria

Can open My Computer, see virtual drives
Can navigate into folders, see contents
Can go up/back/forward through navigation
Can open multiple explorer windows showing different folders
Double-clicking .exe files launches corresponding program
Desktop folder shows actual desktop icon layout
Recycle Bin folder shows deleted desktop items

Best Practices

File Explorer state takes initial_path parameter
Each explorer window is independent instance
Use icons from Program Registry for .exe files
Special folders query live data (Desktop icons, Recycle Bin contents)
Address bar allows manual path entry (for power users)


Phase 6: Desktop Icon Manipulation (Days 14-16)
Goal
Make desktop icons fully interactive with drag, delete, and layout persistence.
Deliverables
Icon Dragging System

Click and hold icon to start drag
Visual feedback during drag (icon follows cursor, or semi-transparent copy)
Snap to grid (optional) or free positioning
Drop icon to set new position
Update Desktop Icon Model with new position
Save position immediately (or on desktop exit)

Icon Deletion System

Right-click icon → Delete option
Or drag icon to Recycle Bin (if visible)
Icon disappears from desktop (marked as deleted)
Icon still appears in Start Menu and Run dialog
Deleted icon appears in Recycle Bin folder when opened

Recycle Bin Integration

Recycle Bin icon shows visual indicator when not empty
Opening Recycle Bin shows File Explorer with deleted items
Right-click deleted item → Restore (returns to desktop at original position)
"Empty Recycle Bin" command (confirmation dialog)
Emptying bin permanently marks icons as deleted (still in Start Menu)

Layout Persistence

Desktop loads saved icon positions on startup
New icons appear in default grid layout
Moved icons remember their position
Deleted icons don't appear (unless restored)
Handle resolution changes gracefully (clamp positions)

Desktop View Updates

Desktop View queries Desktop Icon Model for positions
Desktop View respects deleted state (doesn't render deleted icons)
Desktop View handles mouse events for drag/click/right-click
Desktop View shows grid lines during drag (optional)

Testing Criteria

Can drag any desktop icon to new position
Position persists after restarting game
Can delete desktop icon (disappears from desktop)
Deleted icon appears in Recycle Bin when opened
Can restore deleted icon (reappears at original position)
Can empty Recycle Bin (deleted icons stay hidden)
Deleted programs still appear in Start Menu
Icons can't be dragged off-screen entirely
Multiple icons can be moved/deleted in same session

Best Practices

Save desktop layout to separate file (desktop_layout.json)
Use drag threshold (must move 5+ pixels before drag starts)
Show drop preview or snap-to-grid indicator during drag
Confirmation dialog before emptying Recycle Bin
Store original positions in Recycle Bin (for restore)
Desktop Icon Model validates positions on load (handle bad data)


Phase 7: Window Resizing & Advanced Features (Days 17-18)
Goal
Polish windowing system with resizing, edge cases, and quality of life features.
Deliverables
Window Resizing Implementation

Detect mouse hover on window edges (8px hit zone)
Change cursor appearance on resize edges (arrows)
Support 8 resize directions (4 edges, 4 corners)
Drag edge/corner to resize window
Enforce minimum window size
Enforce maximum window size (screen bounds)
Maintain aspect ratio for corner resizing (optional)

Window Constraints

Mark windows as non-resizable in Program Registry (Settings, etc.)
Mark windows as single-instance (only one can be open)
Handle maximize/restore toggle correctly
Prevent minimizing the last open window (if rule needed)
Handle window opening when another is already maximized

Keyboard Shortcuts

Alt+F4 closes active window
Alt+Tab cycles through windows (optional, complex)
Alt+Space opens window menu (optional)
Windows key opens Start Menu (optional)

Window Memory System

Remember last size/position per program type
New windows open at remembered size/position
Override for programs that should always be maximized
Clear old window positions on save file wipe

Testing Criteria

Can resize any resizable window from all 8 directions
Cursor changes appropriately on window edges
Cannot resize below minimum size
Cannot resize beyond screen bounds
Settings window cannot be resized (marked non-resizable)
Only one VM Manager can open at a time (single-instance)
Can open multiple File Explorer windows (multi-instance)
Alt+F4 closes focused window
Windows remember their last size/position

Best Practices

Resize cursor changes in window controller update()
Store cursor state to restore after resize completes
Define resizable/multi-instance flags in Program Registry
Window memory stored in Window Manager model
Hit zones for resize should be generous (8-10px)


Phase 8: Integration Testing & Polish (Days 19-21)
Goal
Comprehensive testing of entire system working together and bug fixes.
Deliverables
Full System Integration Test

Open 5+ windows simultaneously
Drag windows around, resize them
Minimize/maximize/restore all windows
Switch focus between windows
Close windows in various orders
Move desktop icons around
Delete and restore icons
Browse file explorer through multiple directories
Launch programs from explorer
Verify taskbar stays synchronized

Edge Case Handling

Open window with another already maximized (what happens?)
Minimize all windows (desktop fully visible)
Close focused window (focus moves to next window)
Resize window smaller than its content (needs scrolling?)
Drag window partially off-screen (clamp or allow?)
Delete icon that has an open window (window stays open)
Restore deleted icon while its window is open
Save/load with windows open (restore state or start fresh?)

Performance Testing

10+ windows open simultaneously (frame rate?)
Complex window with many VMs updating (Space Defender + VM Manager)
Rapid window creation/destruction (memory leaks?)
Desktop with 20+ icons (rendering performance?)

Bug Fixing

Fix input routing issues (clicks going to wrong window)
Fix z-order bugs (window gets stuck behind another)
Fix taskbar synchronization issues
Fix desktop icon collision/overlap issues
Fix save/load corruption issues
Fix window dragging stuttering or lag

Visual Polish

Window shadows (optional)
Smooth animations for minimize/maximize (optional)
Better window button icons (actual graphics vs rectangles)
Improved desktop icon rendering
Fade effect on window focus change (optional)
Sound effects for window actions (optional)

Testing Criteria

All features work together without conflicts
No crashes during normal use
No memory leaks during extended play
Frame rate stays above 50 FPS with 10 windows
Save/load preserves all desktop state correctly
All edge cases handled gracefully (no undefined behavior)
UI feels responsive and polished

Best Practices

Use profiling to identify performance bottlenecks
Add debug overlay showing window count, focus, z-order
Test on both full HD and lower resolutions
Test with different window counts (1, 5, 10, 20)
Create automated test scenarios (scripted inputs)


Phase 9: Documentation & Final Touches (Days 22-23)
Goal
Document the new systems and add player-facing improvements.
Deliverables
Code Documentation

Document Window Manager API
Document Desktop Icon Model API
Document File System structure format
Document how to add new windowed programs
Document window constraints and flags
Update AI Guidelines document with windowing patterns

Player-Facing Features

Tutorial updated to mention window management
Help file (in Notepad) explaining desktop interactions
Keyboard shortcut reference document
"About Windows" dialog showing version info (easter egg)

Configuration Options

Settings toggle: Snap windows to grid
Settings toggle: Animate window transitions
Settings slider: Window animation speed
Settings toggle: Show desktop grid lines

Final Adjustments

Adjust default window sizes for optimal UX
Set sensible defaults for icon grid layout
Define which programs should be single-instance
Define which programs should open maximized
Add window menu animations (if not done)

Testing Criteria

All documentation is accurate and helpful
Tutorial successfully guides new players
Settings options work as expected
Default configurations feel intuitive
No placeholder graphics remain
All text is proofread and polished


Success Criteria Summary
Must Have (MVP)

Multiple windows can be open simultaneously
Windows can be dragged, minimized, maximized, closed
Windows appear in taskbar and can be focused from taskbar
Desktop icons can be moved and remember positions
Desktop icons can be deleted and restored via Recycle Bin
File Explorer can browse virtual filesystem
Programs launch in windows instead of fullscreen
My Computer and Recycle Bin are functional

Should Have

Windows can be resized from edges/corners
Non-resizable windows marked appropriately
Single-instance programs enforced
Window positions remembered per program type
Keyboard shortcuts (Alt+F4 minimum)
Performance acceptable with 10+ windows

Nice to Have

Window animations (minimize/maximize)
Window shadows or visual effects
Alt+Tab window cycling
Desktop grid snapping
File Explorer sorting/view options
Right-click context menus
Sound effects for window actions


Risk Mitigation
Technical Risks

Input routing complexity: Build robust hit-testing system early, test thoroughly
Performance with many windows: Profile early, optimize rendering, use dirty flags
Save/load state explosion: Keep window state minimal, use defaults, handle corruption
Z-order bugs: Implement comprehensive window manager tests, log all z-order changes

Scope Risks

Feature creep: Stick to MVP list, defer Nice-to-Haves to post-launch
Complex interactions: Test each phase independently before moving forward
Time overruns: Each phase has buffer time, can cut Nice-to-Haves if needed

Integration Risks

Breaking existing functionality: Test existing features after each phase
State machine conflicts: Ensure window system sits cleanly above state machine
Save file compatibility: Version save files, provide migration path


Development Principles

Test each phase independently before moving to next
Models before views - data structures first, rendering second
One window type working perfectly before converting all
Graceful degradation - handle missing data, corrupted saves
Input validation - clamp positions, validate sizes, check bounds
Clear separation - models agnostic of rendering, views stateless where possible
Document as you go - complex systems need inline documentation
Profile regularly - catch performance issues early