Refactoring Action Plan (with File Dependencies)
This plan will systematically improve the codebase by addressing architectural weaknesses in a logical order, starting with foundational changes and moving to more complex pattern implementations.

Section 1: Foundational Cleanup & Dependency Injection (DI) Consistency
This section focuses on removing reliance on global state and standardizing how modules access shared dependencies like configuration and utility services.

Phase 1.1: Standardize Configuration Access
Issue: The main configuration file (src/config.lua) is accessed inconsistently. Some modules use the injected di container, while others use a global fallback (rawget(_G, 'DI_CONFIG')) or a direct require.

Refactor Goal: Enforce a single, consistent pattern for accessing configuration: strictly through the di container passed during initialization.

Action Plan:

Modify main.lua: Remove the global assignment.

Codebase Search: Find all files using rawget(_G, 'DI_CONFIG') or require('src/config').

Refactor Modules (Iterative): Modify each identified file to accept and use self.di.config. Ensure the di container is passed correctly during instantiation (mainly in main.lua and DesktopState.lua).

Files Required for this Phase:

main.lua

src/config.lua

Any file found in the search that uses the deprecated patterns. This will likely include many files in:

src/models/ (e.g., vm_manager.lua, window_manager.lua)

src/states/ (e.g., desktop_state.lua, game states, control panel states)

src/views/ (e.g., desktop_view.lua, vm_manager_view.lua, ui_components.lua)

src/utils/ (e.g., settings_manager.lua, save_manager.lua)

src/controllers/ (e.g., window_controller.lua)

src/games/ (e.g., dodge_game.lua, space_shooter.lua)

Phase 1.2: Eliminate Singletons via Dependency Injection
Issue: Key utility modules (SpriteLoader, PaletteManager, SpriteManager) are implemented as Singletons using getInstance().

Refactor Goal: Convert these singletons into regular classes instantiated in main.lua and distributed through the di container.

Action Plan:

Modify main.lua: Instantiate the managers and add them to the di table.

Modify Utility Modules: Remove singleton patterns (getInstance, instance variable) and change the return value to the class itself.

Codebase Search & Replace: Find all uses of getInstance().

Update Consumers (Iterative): Modify consumers to accept managers via di in their init and replace getInstance() calls with direct property access (e.g., self.sprite_loader).

Files Required for this Phase:

main.lua

src/utils/sprite_loader.lua

src/utils/palette_manager.lua

src/utils/sprite_manager.lua

Any file found in the search that uses getInstance(). This will likely include many files in:

src/views/ (e.g., desktop_view.lua, start_menu_view.lua, game views, ui_components.lua)

src/states/ (e.g., solitaire_state.lua's view usage)

Section 2: Stricter Model-View-Controller (MVC) Boundaries
This section focuses on improving the separation between Views and their corresponding States/Controllers.

Phase 2.1: Decouple Views by Passing Data Explicitly
Issue: Many Views access their controller/state's data directly (e.g., self.controller.player_data).

Refactor Goal: Modify Views so they only render data explicitly passed as arguments to their draw and update methods.

Action Plan (Iterative for each major View):

Target Views: VMManagerView, LauncherView, CheatEngineView, StatisticsView, FileExplorerView.

For each target View and its corresponding State:

Identify Dependencies: List properties accessed via self.controller or other non-local references within the View.

Modify View Method Signatures: Add parameters to drawWindowed/draw and update for all identified data.

Update State's Call: Modify the State's call to the View method, gathering and passing the required data as arguments.

Refactor the View: Replace direct external property access with the new function parameters.

Files Required for this Phase (Repeat for each pair):

Pair 1:

src/views/vm_manager_view.lua

src/states/vm_manager_state.lua

src/models/vm_manager.lua (for context on data structure)

src/models/player_data.lua (for context on data structure)

Pair 2:

src/views/launcher_view.lua

src/states/launcher_state.lua

src/models/player_data.lua (for context)

src/models/game_data.lua (for context)

Pair 3:

src/views/cheat_engine_view.lua

src/states/cheat_engine_state.lua

src/models/player_data.lua (for context)

src/models/game_data.lua (for context)

src/models/cheat_system.lua (for context)

Pair 4:

src/views/statistics_view.lua

src/states/statistics_state.lua

src/models/statistics.lua (for context)

Pair 5:

src/views/file_explorer_view.lua

src/states/file_explorer_state.lua

src/models/file_system.lua (for context)

src/models/recycle_bin.lua (for context)

src/models/program_registry.lua (for context)

src/models/desktop_icons.lua (for context)

Section 3: Simplify State/Controller Logic
This section aims to manage complexity by breaking down large classes.

Phase 3.1: Refine Start Menu Logic by Empowering its State
Issue: StartMenuView contains complex state management (cascading, DND) that belongs in the State/Controller.

Refactor Goal: Move state and complex interaction logic from StartMenuView to StartMenuState.

Action Plan:

Identify Logic/State in View: Find properties (dnd_active, open_panes, etc.) and methods (updateCascade, DND logic in input methods) in StartMenuView.lua.

Move Properties: Transfer stateful properties to StartMenuState:init.

Move Logic: Transfer the identified complex logic into the corresponding methods (update, mousepressed, etc.) in StartMenuState.lua.

Simplify View: Refactor StartMenuView input methods to perform only hit-testing and return simple events. Update its draw method to accept necessary data (like open_panes) as arguments.

Update State's Draw Call: Modify StartMenuState:draw to pass the required data to self.view:draw.

Files Required for this Phase:

src/views/start_menu_view.lua

src/states/start_menu_state.lua

src/models/program_registry.lua (for context on DND logic)

src/models/file_system.lua (for context on DND logic)

Section 4: Decouple Communication with an Event Bus
This section introduces an event bus to replace direct calls and complex return value handling.

Phase 4.1: Implement a Simple Event Bus Utility
Issue: Components are tightly coupled through direct method calls and specific return value structures for cross-component communication.

Refactor Goal: Create a central Event Bus for publish/subscribe communication.

Action Plan:

Create event_bus.lua: New file.

Implement Bus: Add subscribe, publish, getInstance methods, and internal listener storage.

Integrate into DI: Instantiate in main.lua and add the instance to the di container.

Files Required for this Phase:

src/utils/event_bus.lua (Create and implement)

main.lua (Instantiate and add to DI)

Phase 4.2: Refactor Program Launching to Use Events
Issue: Program launching relies on returning specific event tables up the call stack.

Refactor Goal: Have launchers publish a ProgramLaunchRequested event, and DesktopState subscribe to it.

Action Plan:

Subscribe in DesktopState: Add self.di.eventBus:subscribe(...) call in DesktopState:init.

Codebase Search & Replace: Find all returns of { name = "launch_program", ... } or { name = "launch_minigame", ... }.

Update Publishers (Iterative): Replace returns with self.di.eventBus:publish('ProgramLaunchRequested', ...). Ensure publishers have self.di.

Remove Old Handling: Remove checks for these specific return tables in DesktopState.

Files Required for this Phase:

src/states/desktop_state.lua (Subscriber, remove old handler)

src/utils/event_bus.lua (Reference)

Publisher Files (modify these):

src/states/start_menu_state.lua

src/states/file_explorer_state.lua

src/states/cheat_engine_state.lua

src/states/control_panel_desktop_state.lua (for wallpaper picker)

src/states/solitaire_settings_state.lua (for back picker)

Potentially others found during the search.

Phase 4.3: Refactor Window Closing to Use Events
Issue: Closing windows relies on returning { type = "close_window" }.

Refactor Goal: Have states publish WindowCloseRequested event with their window_id.

Action Plan:

Subscribe in DesktopState: Add self.di.eventBus:subscribe(...) in DesktopState:init.

Codebase Search & Replace: Find all returns of { type = "close_window" }.

Update Publishers (Iterative): Replace returns with self.di.eventBus:publish('WindowCloseRequested', self.window_id). Ensure states have self.window_id and self.di.

Remove Old Handling: Remove checks for this return value in DesktopState and WindowController.

Files Required for this Phase:

src/states/desktop_state.lua (Subscriber, remove old handler)

src/controllers/window_controller.lua (Remove old handler)

src/utils/event_bus.lua (Reference)

Publisher Files (modify these):

src/states/minigame_state.lua

src/states/launcher_state.lua

src/states/vm_manager_state.lua

src/states/statistics_state.lua

src/states/cheat_engine_state.lua

src/states/settings_state.lua

src/states/file_explorer_state.lua

src/states/shutdown_state.lua

src/states/run_dialog_state.lua

src/states/control_panel_general_state.lua

src/states/control_panel_desktop_state.lua

src/states/control_panel_screensavers_state.lua

src/states/solitaire_settings_state.lua

src/states/solitaire_back_picker_state.lua

src/states/wallpaper_picker_state.lua

Potentially others found during the search.

Section 5: Final Polish
This section addresses final consistency and robustness improvements.

Phase 5.1: Standardize Error Handling and Reporting
Issue: pcall usage is good, but error logging and user feedback are inconsistent.

Refactor Goal: Standardize error logging format and apply a rule for when to use console logs vs. user message boxes.

Action Plan:

Codebase Search: Find all pcall instances.

Review pcall Usage (Iterative): For each pcall:

Ensure failures print a standardized error message to the console including module/method context.

Apply the rule: Log background/loop errors silently (print); show love.window.showMessageBox for errors directly resulting from user actions (clicks, etc.).

Files Required for this Phase:

Any file found in the search that uses pcall. This is widespread and will require examining most .lua files in src/, lib/, and main.lua. Key areas include:

File loading (JSON, assets) in models and utilities.

State method calls within DesktopState, WindowController, and StateMachine.

External library calls (json.decode, love.filesystem operations).

Game logic updates (updateBase, updateGameLogic).