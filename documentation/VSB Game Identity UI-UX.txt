# AI Development Guidelines for "10,000 Games Collection" - **REVISED AND SIMPLIFIED**

This document outlines the **STRICT** rules and coding standards to follow when using an AI assistant (like Gemini) to generate or modify code for this project. **FAILURE TO FOLLOW THESE RULES, ESPECIALLY REGARDING CODE BLOCKS, WILL RESULT IN IMMEDIATE CORRECTION.**

## 1. Code Presentation - **MANDATORY RULES**

**1.1. CODE BLOCK FORMATTING - THE CARDINAL RULE:**

* **ONE ITEM PER BLOCK:** Each code block MUST contain EXACTLY ONE complete item:
    * Either ONE **entire, non-truncated file**.
    * Or ONE **complete, non-truncated function**.
* **NO INSTRUCTIONS INSIDE BLOCKS:** Code blocks contain ONLY CODE. Absolutely NO comments, explanations, instructions (like `-- Add this function` or `// Replace below`), or any non-code text are permitted inside the ``` ``` delimiters, unless it's actual code comments intrinsic to the function/file itself.
* **NO TRUNCATION:** Files and functions provided MUST be complete. Do NOT use "..." or omit sections.
* **VIOLATION:** Including instructions, comments about changes, or multiple files/functions within a single code block is a direct violation of this rule and will be rejected.

**1.2. INSTRUCTIONS OUTSIDE CODE BLOCKS:**

* **MINIMAL TEXT:** Keep explanatory text concise.
* **REQUIRED INFO:** For each code block provided, state ONLY:
    * The **full, exact file path** the code belongs to.
    * The **action** (e.g., "Replace entire file", "Replace function `functionName`", "Add function `functionName`", "Create new file").
* **NO LONG EXPLANATIONS:** Do NOT provide lengthy descriptions of what the code does or the changes made unless specifically requested. Assume the user understands the code's purpose from the context and the code itself.

**1.3. TESTING GUIDANCE:**

* **CONSOLIDATED AT END:** ALL testing guidance MUST be grouped together in a single section at the VERY END of the entire response, *after* all code blocks and their minimal instructions.
* **BE SPECIFIC:** Provide clear, numbered steps on *how* to test the changes to verify correctness.
* **EXPECTED OUTCOME:** Briefly state the expected result of the changes.

## 2. Architectural Principles

* **Dependency Injection:** Inject only **specific dependencies** (`player_data`, `state_machine`, etc.) via constructors (`init`). NO god objects. NO global variables for state sharing.
* **MVC / State Pattern:**
    * **Models:** Data and logic only. No rendering. Unaware of views/states.
    * **Views:** Handle ALL drawing. Stateful UI classes. Input methods return simple events/data. Receive data from Controller/State.
    * **Controllers / States:** Mediate. Handle flow, update models, pass data to views. Game logic belongs in `src/games/` instances.
* **State Machine:** Use the central state machine for major section transitions.

## 3. Code Quality & Refactoring Practices

* **`require` at Top:** All `require` calls at file scope (top of file), outside functions, unless dynamically loading game classes.
* **Externalize Data:** Game definitions, level data, etc., MUST be in JSON files (`assets/data/`). Use `pcall` safely if loading functions from data strings.
* **NO Magic Numbers:** Use named constants (top of file or `config.lua`).
* **Central Config:** Tuning parameters (costs, multipliers, speeds, timers) belong in `config.lua`.
* **Use Utilities:** Use `collision.lua`, `ui_components.lua`, etc., consistently.
* **Safe Update Flow:** Use patterns like `updateBase()` + `updateGameLogic()` for inherited classes to avoid mandatory `super` calls in subclasses.
* **Object Pooling:** Use for frequently created/destroyed objects (e.g., bullets).
* **Input Handling:** Active state/view handles input first. Return `true` if handled. Global shortcuts only if unhandled.
* **Error Handling:** Use `pcall` for file I/O, JSON parsing, `loadstring`, etc.

**Adherence to Rule 1.1 is PARAMOUNT.** Follow these guidelines precisely to ensure code quality and maintainability.