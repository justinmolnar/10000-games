local BaseGame = require('src.games.base_game')
local Config = rawget(_G, 'DI_CONFIG') or {}
local RPSView = require('src.games.views.rps_view')
local ScorePopup = require('src.games.score_popup')
local VisualEffects = require('src.utils.game_components.visual_effects')
local RPS = BaseGame:extend('RPS')

-- Config-driven defaults with safe fallbacks
local DEFAULT_ROUNDS_TO_WIN = 3
local DEFAULT_GAME_MODE = "rps"
local DEFAULT_AI_PATTERN = "random"
local DEFAULT_AI_BIAS = 0.33  -- Equal probability for all choices
local DEFAULT_AI_BIAS_STRENGTH = 0.5  -- How much bias affects AI
local DEFAULT_TIME_PER_ROUND = 0  -- Unlimited
local DEFAULT_ROUND_RESULT_DISPLAY_TIME = 2.0
local DEFAULT_SHOW_AI_PATTERN_HINT = false
local DEFAULT_SHOW_PLAYER_HISTORY = true

-- Scoring defaults
local DEFAULT_SCORE_PER_ROUND_WIN = 100
local DEFAULT_STREAK_BONUS = 50  -- Bonus points per consecutive win
local DEFAULT_PERFECT_GAME_BONUS = 500
local DEFAULT_SCORE_POPUP_ENABLED = true

-- Phase 6 completion: Double hands mode defaults
local DEFAULT_HANDS_MODE = "single"  -- "single" or "double"
local DEFAULT_TIME_PER_REMOVAL = 0  -- Unlimited time to choose which hand to remove
local DEFAULT_BOTH_HANDS_HISTORY_LENGTH = 10  -- Show last N rounds of both-hands history
local DEFAULT_SHOW_OPPONENT_HANDS = true  -- Show opponent's both hands during removal phase

-- Phase 6 completion: Multiple opponents defaults
local DEFAULT_NUM_OPPONENTS = 1  -- 1-5 AI opponents
local DEFAULT_ELIMINATION_MODE = false  -- If true, eliminated opponents don't respawn

-- Phase 6 completion: Victory conditions defaults
local DEFAULT_VICTORY_CONDITION = "rounds"  -- "rounds", "first_to", "streak", "total", "time"
local DEFAULT_FIRST_TO_TARGET = 5  -- First to X wins
local DEFAULT_STREAK_TARGET = 5  -- Win X consecutive rounds
local DEFAULT_TOTAL_WINS_TARGET = 10  -- Total wins required
local DEFAULT_TIME_LIMIT = 60  -- Seconds (for "time" mode)

-- Phase 6 completion: Lives system defaults
local DEFAULT_LIVES = 999  -- Unlimited by default
local DEFAULT_LOSE_LIFE_ON = "loss"  -- "loss", "tie", "both"

-- Phase 6 completion: Special rounds defaults
local DEFAULT_SPECIAL_ROUNDS_ENABLED = false
local DEFAULT_DOUBLE_OR_NOTHING_ENABLED = false  -- Win = +2 points, lose = -1 point
local DEFAULT_SUDDEN_DEATH_ENABLED = false  -- One round, winner takes all
local DEFAULT_REVERSE_MODE_ENABLED = false  -- Win conditions reversed
local DEFAULT_MIRROR_MODE_ENABLED = false  -- Both players must throw same thing to win

-- Phase 6 completion: Display defaults
local DEFAULT_SHOW_HISTORY_DISPLAY = false  -- Show last N throws
local DEFAULT_HISTORY_LENGTH = 10
local DEFAULT_SHOW_STATISTICS = false  -- Show win/loss/tie percentages
local DEFAULT_AI_PATTERN_DELAY = 0  -- Rounds before AI pattern activates

-- Win matrices for different game modes
local WIN_MATRICES = {
    rps = {
        rock = { beats = {"scissors"}, loses_to = {"paper"} },
        paper = { beats = {"rock"}, loses_to = {"scissors"} },
        scissors = { beats = {"paper"}, loses_to = {"rock"} }
    },
    rpsls = {
        rock = { beats = {"scissors", "lizard"}, loses_to = {"paper", "spock"} },
        paper = { beats = {"rock", "spock"}, loses_to = {"scissors", "lizard"} },
        scissors = { beats = {"paper", "lizard"}, loses_to = {"rock", "spock"} },
        lizard = { beats = {"paper", "spock"}, loses_to = {"rock", "scissors"} },
        spock = { beats = {"rock", "scissors"}, loses_to = {"paper", "lizard"} }
    },
    rpsfb = {
        rock = { beats = {"scissors"}, loses_to = {"paper", "water"} },
        paper = { beats = {"rock"}, loses_to = {"scissors", "fire"} },
        scissors = { beats = {"paper"}, loses_to = {"rock", "water"} },
        fire = { beats = {"paper", "scissors"}, loses_to = {"water", "rock"} },
        water = { beats = {"fire", "rock"}, loses_to = {"paper", "scissors"} }
    }
}

function RPS:init(game_data, cheats, di, variant_override)
    RPS.super.init(self, game_data, cheats, di, variant_override)
    self.di = di

    -- Three-tier fallback: runtimeCfg → variant → DEFAULT
    local runtimeCfg = (self.di and self.di.config and self.di.config.games and self.di.config.games.rps)

    -- Load parameters with three-tier fallback
    self.rounds_to_win = (runtimeCfg and runtimeCfg.rounds_to_win) or DEFAULT_ROUNDS_TO_WIN
    if self.variant and self.variant.rounds_to_win ~= nil then
        self.rounds_to_win = self.variant.rounds_to_win
    end

    self.game_mode = (runtimeCfg and runtimeCfg.game_mode) or DEFAULT_GAME_MODE
    if self.variant and self.variant.game_mode ~= nil then
        self.game_mode = self.variant.game_mode
    end

    self.ai_pattern = (runtimeCfg and runtimeCfg.ai_pattern) or DEFAULT_AI_PATTERN
    if self.variant and self.variant.ai_pattern ~= nil then
        self.ai_pattern = self.variant.ai_pattern
    end

    -- AI Behavior Parameters
    self.ai_bias = (runtimeCfg and runtimeCfg.ai_bias) or DEFAULT_AI_BIAS
    if self.variant and self.variant.ai_bias ~= nil then
        self.ai_bias = self.variant.ai_bias
    end

    self.ai_bias_strength = (runtimeCfg and runtimeCfg.ai_bias_strength) or DEFAULT_AI_BIAS_STRENGTH
    if self.variant and self.variant.ai_bias_strength ~= nil then
        self.ai_bias_strength = self.variant.ai_bias_strength
    end

    -- Timing Parameters
    self.time_per_round = (runtimeCfg and runtimeCfg.time_per_round) or DEFAULT_TIME_PER_ROUND
    if self.variant and self.variant.time_per_round ~= nil then
        self.time_per_round = self.variant.time_per_round
    end

    self.round_result_display_time = (runtimeCfg and runtimeCfg.round_result_display_time) or DEFAULT_ROUND_RESULT_DISPLAY_TIME
    if self.variant and self.variant.round_result_display_time ~= nil then
        self.round_result_display_time = self.variant.round_result_display_time
    end

    -- Display Parameters
    self.show_ai_pattern_hint = (runtimeCfg and runtimeCfg.show_ai_pattern_hint) or DEFAULT_SHOW_AI_PATTERN_HINT
    if self.variant and self.variant.show_ai_pattern_hint ~= nil then
        self.show_ai_pattern_hint = self.variant.show_ai_pattern_hint
    end

    self.show_player_history = (runtimeCfg and runtimeCfg.show_player_history) or DEFAULT_SHOW_PLAYER_HISTORY
    if self.variant and self.variant.show_player_history ~= nil then
        self.show_player_history = self.variant.show_player_history
    end

    -- Apply difficulty_modifier from variant
    if self.variant and self.variant.difficulty_modifier then
        self.time_per_round = self.time_per_round * self.variant.difficulty_modifier
        self.round_result_display_time = self.round_result_display_time * self.variant.difficulty_modifier
    end

    -- Apply CheatEngine modifications
    if self.cheats.speed_modifier then
        self.round_result_display_time = self.round_result_display_time * self.cheats.speed_modifier
        self.time_per_round = self.time_per_round * self.cheats.speed_modifier
    end
    if self.cheats.advantage_modifier then
        self.rounds_to_win = math.max(1, self.rounds_to_win - math.floor((self.cheats.advantage_modifier or 0) / 2))
    end
    if self.cheats.performance_modifier then
        -- Show hints when performance modifier is active
        self.show_ai_pattern_hint = true
        self.show_player_history = true
    end

    -- Scoring parameters
    self.score_per_round_win = (runtimeCfg and runtimeCfg.score_per_round_win) or DEFAULT_SCORE_PER_ROUND_WIN
    if self.variant and self.variant.score_per_round_win ~= nil then
        self.score_per_round_win = self.variant.score_per_round_win
    end

    self.streak_bonus = (runtimeCfg and runtimeCfg.streak_bonus) or DEFAULT_STREAK_BONUS
    if self.variant and self.variant.streak_bonus ~= nil then
        self.streak_bonus = self.variant.streak_bonus
    end

    self.perfect_game_bonus = (runtimeCfg and runtimeCfg.perfect_game_bonus) or DEFAULT_PERFECT_GAME_BONUS
    if self.variant and self.variant.perfect_game_bonus ~= nil then
        self.perfect_game_bonus = self.variant.perfect_game_bonus
    end

    self.score_popup_enabled = (runtimeCfg and runtimeCfg.score_popup_enabled) or DEFAULT_SCORE_POPUP_ENABLED
    if self.variant and self.variant.score_popup_enabled ~= nil then
        self.score_popup_enabled = self.variant.score_popup_enabled
    end

    -- Phase 6 completion: Double hands mode parameters
    self.hands_mode = (runtimeCfg and runtimeCfg.hands_mode) or DEFAULT_HANDS_MODE
    if self.variant and self.variant.hands_mode ~= nil then
        self.hands_mode = self.variant.hands_mode
    end

    self.time_per_removal = (runtimeCfg and runtimeCfg.time_per_removal) or DEFAULT_TIME_PER_REMOVAL
    if self.variant and self.variant.time_per_removal ~= nil then
        self.time_per_removal = self.variant.time_per_removal
    end

    self.both_hands_history_length = (runtimeCfg and runtimeCfg.both_hands_history_length) or DEFAULT_BOTH_HANDS_HISTORY_LENGTH
    if self.variant and self.variant.both_hands_history_length ~= nil then
        self.both_hands_history_length = self.variant.both_hands_history_length
    end

    self.show_opponent_hands = (runtimeCfg and runtimeCfg.show_opponent_hands) or DEFAULT_SHOW_OPPONENT_HANDS
    if self.variant and self.variant.show_opponent_hands ~= nil then
        self.show_opponent_hands = self.variant.show_opponent_hands
    end

    -- Phase 6 completion: Multiple opponents parameters
    self.num_opponents = (runtimeCfg and runtimeCfg.num_opponents) or DEFAULT_NUM_OPPONENTS
    if self.variant and self.variant.num_opponents ~= nil then
        self.num_opponents = self.variant.num_opponents
    end
    self.num_opponents = math.max(1, math.min(5, self.num_opponents))  -- Clamp 1-5

    self.elimination_mode = (runtimeCfg and runtimeCfg.elimination_mode) or DEFAULT_ELIMINATION_MODE
    if self.variant and self.variant.elimination_mode ~= nil then
        self.elimination_mode = self.variant.elimination_mode
    end

    -- Phase 6 completion: Victory conditions parameters
    self.victory_condition = (runtimeCfg and runtimeCfg.victory_condition) or DEFAULT_VICTORY_CONDITION
    if self.variant and self.variant.victory_condition ~= nil then
        self.victory_condition = self.variant.victory_condition
    end

    self.first_to_target = (runtimeCfg and runtimeCfg.first_to_target) or DEFAULT_FIRST_TO_TARGET
    if self.variant and self.variant.first_to_target ~= nil then
        self.first_to_target = self.variant.first_to_target
    end

    self.streak_target = (runtimeCfg and runtimeCfg.streak_target) or DEFAULT_STREAK_TARGET
    if self.variant and self.variant.streak_target ~= nil then
        self.streak_target = self.variant.streak_target
    end

    self.total_wins_target = (runtimeCfg and runtimeCfg.total_wins_target) or DEFAULT_TOTAL_WINS_TARGET
    if self.variant and self.variant.total_wins_target ~= nil then
        self.total_wins_target = self.variant.total_wins_target
    end

    self.time_limit = (runtimeCfg and runtimeCfg.time_limit) or DEFAULT_TIME_LIMIT
    if self.variant and self.variant.time_limit ~= nil then
        self.time_limit = self.variant.time_limit
    end

    -- Phase 6 completion: Lives system parameters
    self.lives = (runtimeCfg and runtimeCfg.lives) or DEFAULT_LIVES
    if self.variant and self.variant.lives ~= nil then
        self.lives = self.variant.lives
    end

    self.lose_life_on = (runtimeCfg and runtimeCfg.lose_life_on) or DEFAULT_LOSE_LIFE_ON
    if self.variant and self.variant.lose_life_on ~= nil then
        self.lose_life_on = self.variant.lose_life_on
    end

    -- Phase 6 completion: Special rounds parameters
    self.special_rounds_enabled = (runtimeCfg and runtimeCfg.special_rounds_enabled) or DEFAULT_SPECIAL_ROUNDS_ENABLED
    if self.variant and self.variant.special_rounds_enabled ~= nil then
        self.special_rounds_enabled = self.variant.special_rounds_enabled
    end

    self.double_or_nothing_enabled = (runtimeCfg and runtimeCfg.double_or_nothing_enabled) or DEFAULT_DOUBLE_OR_NOTHING_ENABLED
    if self.variant and self.variant.double_or_nothing_enabled ~= nil then
        self.double_or_nothing_enabled = self.variant.double_or_nothing_enabled
    end

    self.sudden_death_enabled = (runtimeCfg and runtimeCfg.sudden_death_enabled) or DEFAULT_SUDDEN_DEATH_ENABLED
    if self.variant and self.variant.sudden_death_enabled ~= nil then
        self.sudden_death_enabled = self.variant.sudden_death_enabled
    end

    self.reverse_mode_enabled = (runtimeCfg and runtimeCfg.reverse_mode_enabled) or DEFAULT_REVERSE_MODE_ENABLED
    if self.variant and self.variant.reverse_mode_enabled ~= nil then
        self.reverse_mode_enabled = self.variant.reverse_mode_enabled
    end

    self.mirror_mode_enabled = (runtimeCfg and runtimeCfg.mirror_mode_enabled) or DEFAULT_MIRROR_MODE_ENABLED
    if self.variant and self.variant.mirror_mode_enabled ~= nil then
        self.mirror_mode_enabled = self.variant.mirror_mode_enabled
    end

    -- Phase 6 completion: Display parameters
    self.show_history_display = (runtimeCfg and runtimeCfg.show_history_display) or DEFAULT_SHOW_HISTORY_DISPLAY
    if self.variant and self.variant.show_history_display ~= nil then
        self.show_history_display = self.variant.show_history_display
    end

    self.history_length = (runtimeCfg and runtimeCfg.history_length) or DEFAULT_HISTORY_LENGTH
    if self.variant and self.variant.history_length ~= nil then
        self.history_length = self.variant.history_length
    end

    self.show_statistics = (runtimeCfg and runtimeCfg.show_statistics) or DEFAULT_SHOW_STATISTICS
    if self.variant and self.variant.show_statistics ~= nil then
        self.show_statistics = self.variant.show_statistics
    end

    self.ai_pattern_delay = (runtimeCfg and runtimeCfg.ai_pattern_delay) or DEFAULT_AI_PATTERN_DELAY
    if self.variant and self.variant.ai_pattern_delay ~= nil then
        self.ai_pattern_delay = self.variant.ai_pattern_delay
    end

    -- Initialize game state
    self.player_wins = 0
    self.ai_wins = 0
    self.ties = 0
    self.rounds_played = 0
    self.current_win_streak = 0
    self.max_win_streak = 0
    self.game_over = false
    self.victory = false
    self.score = 0

    -- Round state
    self.waiting_for_input = true
    self.player_choice = nil
    self.ai_choice = nil
    self.round_result = nil  -- "win", "lose", "tie"
    self.result_display_time = 0
    self.show_result = false

    -- AI history for patterns
    self.player_history = {}
    self.ai_history = {}

    -- Phase 6 completion: Double hands mode state
    self.phase = "selection"  -- "selection" or "removal" (for double hands mode)
    self.player_left_hand = nil
    self.player_right_hand = nil
    self.ai_left_hand = nil  -- AI's left hand
    self.ai_right_hand = nil  -- AI's right hand
    self.both_hands_history = {}  -- Track history of both-hands rounds
    self.removal_timer = 0

    -- Phase 6 completion: Multiple opponents state
    self.opponents = {}  -- Array of opponent data {wins, choice, eliminated, pattern, etc}
    for i = 1, self.num_opponents do
        table.insert(self.opponents, {
            id = i,
            wins = 0,
            choice = nil,
            eliminated = false,
            pattern = self.ai_pattern,  -- Each can have different pattern
            history = {}
        })
    end

    -- Phase 6 completion: Time limit state (for "time" victory condition)
    self.time_elapsed = 0

    -- Phase 6 completion: History display state
    self.throw_history = {}  -- Circular buffer of last N throws

    -- Phase 6 completion: Special rounds state
    self.current_special_round = nil  -- "double_or_nothing", "sudden_death", "reverse", "mirror"
    self.last_special_round = nil  -- Track last special round for display during result phase

    -- Initialize metrics table for formula
    self.metrics = {
        rounds_won = 0,
        rounds_lost = 0,
        rounds_total = 0,
        max_win_streak = 0,
        accuracy = 0,
        score = 0
    }

    -- Score popups
    self.score_popups = {}

    -- Visual effects parameters (Phase 11)
    self.throw_animation_style = "hands"  -- "hands", "icons", "text", "emojis"
    if self.variant and self.variant.throw_animation_style ~= nil then
        self.throw_animation_style = self.variant.throw_animation_style
    end

    self.animation_speed = 1.0
    if self.variant and self.variant.animation_speed ~= nil then
        self.animation_speed = self.variant.animation_speed
    end

    local screen_flash_enabled = true
    if self.variant and self.variant.screen_flash_enabled ~= nil then
        screen_flash_enabled = self.variant.screen_flash_enabled
    end

    self.celebration_on_perfect = true
    if self.variant and self.variant.celebration_on_perfect ~= nil then
        self.celebration_on_perfect = self.variant.celebration_on_perfect
    end

    -- Phase 3: Initialize VisualEffects component (screen flash + particles)
    self.visual_effects = VisualEffects:new({
        camera_shake_enabled = false,  -- RPS doesn't use camera shake
        screen_flash_enabled = screen_flash_enabled,
        particle_effects_enabled = true
    })

    -- Animation state
    self.throw_animation_timer = 0
    self.is_animating = false

    -- Create view
    self.view = RPSView:new(self)

    -- Initialize RNG with seed for deterministic AI
    self.rng = love.math.newRandomGenerator(self.seed or os.time())

    -- Try to activate special round for first throw (after RNG is initialized)
    self.current_special_round = self:activateSpecialRound()
    if self.current_special_round then
        print("[RPS] Special round activated for first throw:", self.current_special_round)
    end
end

function RPS:setPlayArea(width, height)
    -- Store viewport dimensions for demo playback
    self.viewport_width = width
    self.viewport_height = height
    print("[RPS] Play area updated to:", width, height)
end

function RPS:updateGameLogic(dt)
    -- Phase 6 completion: Check time limit (for "time" victory condition)
    -- NOTE: time_elapsed is already incremented in BaseGame:updateBase, don't double-increment!
    if not self.game_over and not self.victory and self.victory_condition == "time" then
        if self.time_elapsed >= self.time_limit then
            -- Time's up - trigger victory/game over based on who has more wins
            if self.player_wins > self.ai_wins then
                self.victory = true
            else
                self.game_over = true
            end
        end
    end

    -- Phase 6 completion: Double hands removal timer
    if self.hands_mode == "double" and self.phase == "removal" and self.time_per_removal > 0 then
        self.removal_timer = self.removal_timer - dt
        if self.removal_timer <= 0 then
            -- Time's up - randomly choose one hand to keep for both players
            local player_final = (self.rng:random() < 0.5 and self.player_left_hand) or self.player_right_hand
            local ai_final = (self.rng:random() < 0.5 and self.ai_left_hand) or self.ai_right_hand

            if player_final and ai_final then
                self.ai_choice = ai_final
                self:playRound(player_final)
            end

            self.player_left_hand = nil
            self.player_right_hand = nil
            self.ai_left_hand = nil
            self.ai_right_hand = nil
            self.phase = "selection"
        end
    end

    -- Update throw animation (Phase 11)
    if self.is_animating then
        self.throw_animation_timer = self.throw_animation_timer + dt
        if self.throw_animation_timer >= (0.5 / self.animation_speed) then
            self.is_animating = false
            self.throw_animation_timer = 0
        end
    end

    -- Update visual effects (Phase 3 - VisualEffects component)
    self.visual_effects:update(dt)

    -- Update score popups
    for i = #self.score_popups, 1, -1 do
        local popup = self.score_popups[i]
        popup:update(dt)
        if not popup.alive then
            table.remove(self.score_popups, i)
        end
    end

    -- Handle result display timer
    if self.show_result and not self.game_over and not self.victory then
        self.result_display_time = self.result_display_time + dt
        if self.result_display_time >= self.round_result_display_time then
            self.show_result = false
            self.result_display_time = 0
            self.waiting_for_input = true

            -- Phase 6 completion: Activate special round for NEXT round (when player is about to throw)
            if not self.current_special_round then
                self.current_special_round = self:activateSpecialRound()
                if self.current_special_round then
                    print("[RPS] Special round activated for next throw:", self.current_special_round)
                end
            end
        end
    end
end

function RPS:keypressed(key)
    if not self.waiting_for_input or self.game_over or self.victory then
        return
    end

    -- Handle throw input based on game_mode
    local choice = nil

    -- Basic RPS keys (all modes)
    if key == 'r' then
        choice = 'rock'
    elseif key == 'p' then
        choice = 'paper'
    elseif key == 's' then
        choice = 'scissors'
    end

    -- Extended RPSLS keys
    if self.game_mode == "rpsls" then
        if key == 'l' then
            choice = 'lizard'
        elseif key == 'v' then
            choice = 'spock'
        end
    end

    -- Extended RPSFB keys
    if self.game_mode == "rpsfb" then
        if key == 'f' then
            choice = 'fire'
        elseif key == 'w' then
            choice = 'water'
        end
    end

    -- Phase 6 completion: Double hands mode - handle removal phase number keys FIRST
    if self.hands_mode == "double" and self.phase == "removal" then
        local player_final = nil
        if key == '1' and self.player_left_hand then
            -- Keep left hand, remove right
            player_final = self.player_left_hand
        elseif key == '2' and self.player_right_hand then
            -- Keep right hand, remove left
            player_final = self.player_right_hand
        end

        if player_final then
            -- AI removes one hand (randomly for now, could be strategic)
            local ai_final = (self.rng:random() < 0.5 and self.ai_left_hand) or self.ai_right_hand
            print("[RPS] AI keeps:", ai_final)

            -- Override ai_choice for this round
            self.ai_choice = ai_final

            -- Play the round
            self:playRound(player_final)

            -- Reset hands
            self.player_left_hand = nil
            self.player_right_hand = nil
            self.ai_left_hand = nil
            self.ai_right_hand = nil
            self.phase = "selection"
            return  -- Don't process as normal throw
        end
    end

    if choice then
        -- Phase 6 completion: Double hands mode handling
        if self.hands_mode == "double" then
            if self.phase == "selection" then
                -- Selection phase: choosing both hands
                if not self.player_left_hand then
                    self.player_left_hand = choice
                    print("[RPS] Left hand selected:", choice)
                elseif not self.player_right_hand then
                    self.player_right_hand = choice
                    print("[RPS] Right hand selected:", choice)

                    -- Generate AI's both hands
                    self.ai_left_hand = self:generateAIChoice()
                    self.ai_right_hand = self:generateAIChoice()
                    print("[RPS] AI selected hands:", self.ai_left_hand, self.ai_right_hand)

                    -- Both hands selected, move to removal phase
                    self.phase = "removal"
                    self.waiting_for_input = true
                    self.removal_timer = self.time_per_removal
                end
            end
        else
            -- Single hands mode: standard play
            self:playRound(choice)
        end
    end
end

function RPS:playRoundMultipleOpponents(player_choice)
    -- Phase 6 completion: Handle multiple opponents battle royale
    self.rounds_played = self.rounds_played + 1
    local player_wins_this_round = 0
    local player_losses_this_round = 0
    local player_ties_this_round = 0

    -- Play against each non-eliminated opponent
    for _, opponent in ipairs(self.opponents) do
        if not opponent.eliminated then
            -- Generate AI choice for this opponent
            opponent.choice = self:generateAIChoiceForOpponent(opponent)

            -- Determine winner
            local result = self:determineWinner(player_choice, opponent.choice)

            if result == "win" then
                player_wins_this_round = player_wins_this_round + 1
            elseif result == "lose" then
                player_losses_this_round = player_losses_this_round + 1
                opponent.wins = opponent.wins + 1

                -- Check if opponent has won enough to eliminate player
                if self.elimination_mode and opponent.wins >= self.rounds_to_win then
                    self.game_over = true
                end
            else
                player_ties_this_round = player_ties_this_round + 1
            end

            -- Update opponent history
            table.insert(opponent.history, opponent.choice)
        end
    end

    -- Update player stats based on majority result
    if player_wins_this_round > player_losses_this_round then
        self.player_wins = self.player_wins + 1
        self.current_win_streak = self.current_win_streak + 1
        self.round_result = "win"
    elseif player_losses_this_round > player_wins_this_round then
        self.ai_wins = self.ai_wins + 1
        self.current_win_streak = 0
        self.round_result = "lose"
    else
        self.ties = self.ties + 1
        self.round_result = "tie"
    end

    -- Update max streak
    if self.current_win_streak > self.max_win_streak then
        self.max_win_streak = self.current_win_streak
    end

    -- Check victory
    if self:checkVictoryCondition() then
        self.victory = true
    end

    -- Update metrics
    self.metrics.rounds_won = self.player_wins
    self.metrics.rounds_lost = self.ai_wins
    self.metrics.rounds_total = self.rounds_played
    self.metrics.max_win_streak = self.max_win_streak
    local total_decided = self.player_wins + self.ai_wins
    self.metrics.accuracy = total_decided > 0 and (self.player_wins / total_decided) or 0
    self.metrics.score = self.score

    -- Update history
    table.insert(self.player_history, player_choice)

    -- Show result
    self.show_result = true
    self.result_display_time = 0
end

function RPS:playRound(player_choice)
    self.player_choice = player_choice
    self.waiting_for_input = false

    -- Start throw animation (Phase 11)
    self.is_animating = true
    self.throw_animation_timer = 0

    -- Phase 6 completion: Multiple opponents mode
    if self.num_opponents > 1 then
        self:playRoundMultipleOpponents(player_choice)
        return
    end

    -- NOTE: Special round is activated earlier when waiting_for_input becomes true (see updateGameLogic)

    -- Generate AI choice based on pattern
    self.ai_choice = self:generateAIChoice()

    -- Determine winner (may be modified by special rounds)
    self.round_result = self:determineWinner(player_choice, self.ai_choice)

    -- Phase 6 completion: Apply special round rules
    if self.current_special_round == "reverse" then
        -- Reverse mode: flip win/lose
        if self.round_result == "win" then
            self.round_result = "lose"
        elseif self.round_result == "lose" then
            self.round_result = "win"
        end
    elseif self.current_special_round == "mirror" then
        -- Mirror mode: both must throw same thing to win, otherwise tie
        if player_choice == self.ai_choice then
            self.round_result = "win"  -- Both threw same - player wins
        else
            self.round_result = "tie"
        end
    end

    -- Update stats
    self.rounds_played = self.rounds_played + 1

    if self.round_result == "win" then
        self.player_wins = self.player_wins + 1
        self.current_win_streak = self.current_win_streak + 1

        -- Award score for round win
        local round_points = self.score_per_round_win

        -- Phase 6 completion: Double or nothing special round
        if self.current_special_round == "double_or_nothing" then
            round_points = round_points * 2  -- Double points on win
        end

        self.score = self.score + round_points

        -- Award streak bonus (bonus × streak_length)
        local total_points = round_points
        if self.current_win_streak > 1 then
            local streak_points = self.streak_bonus * self.current_win_streak
            self.score = self.score + streak_points
            total_points = total_points + streak_points
        end

        -- Spawn score popup
        if self.score_popup_enabled then
            local w, h = love.graphics.getDimensions()
            local popup_color = {1, 1, 1}  -- White for round win
            -- Yellow for streak milestones at 3/5
            if self.current_win_streak == 3 or self.current_win_streak == 5 then
                popup_color = {1, 1, 0}
            end
            table.insert(self.score_popups, ScorePopup:new(w / 2, h / 2 - 50, "+" .. math.floor(total_points), popup_color))
        end

        if self.current_win_streak > self.max_win_streak then
            self.max_win_streak = self.current_win_streak
        end

        -- Visual effects: screen flash (green for win) - Phase 11
        self.visual_effects:flash({0, 1, 0, 0.3}, 0.2, "fade_out")  -- Green flash

        -- Phase 6 completion: Sudden death special round - instant victory
        if self.current_special_round == "sudden_death" then
            self.victory = true
        end

        -- Phase 6 completion: Check victory based on victory condition
        if self:checkVictoryCondition() then
            self.victory = true
            -- Award perfect game bonus if won without losing any rounds
            if self.ai_wins == 0 then
                self.score = self.score + self.perfect_game_bonus
                -- Spawn green popup for perfect game
                if self.score_popup_enabled then
                    local w, h = love.graphics.getDimensions()
                    table.insert(self.score_popups, ScorePopup:new(w / 2, h / 2 - 100, "PERFECT GAME! +" .. self.perfect_game_bonus, {0, 1, 0}))
                end

                -- Visual effects: celebration on perfect game - Phase 11
                if self.celebration_on_perfect then
                    local w, h = love.graphics.getDimensions()
                    self.visual_effects:emitConfetti(w / 2, h / 2, 30)
                end
            end
        end
    elseif self.round_result == "lose" then
        self.ai_wins = self.ai_wins + 1
        self.current_win_streak = 0

        -- Phase 6 completion: Double or nothing special round - lose points
        if self.current_special_round == "double_or_nothing" then
            self.score = math.max(0, self.score - self.score_per_round_win)
        end

        -- Phase 6 completion: Sudden death special round - instant game over
        if self.current_special_round == "sudden_death" then
            self.game_over = true
        end

        -- Visual effects: screen flash (red for loss) - Phase 11
        self.visual_effects:flash({1, 0, 0, 0.3}, 0.2, "fade_out")  -- Red flash

        -- Phase 6 completion: Lives system - lose life on loss
        if self.lives < 999 and (self.lose_life_on == "loss" or self.lose_life_on == "both") then
            self.lives = self.lives - 1
            if self.lives <= 0 then
                self.game_over = true
            end
        end

        -- Check game over
        if self.ai_wins >= self.rounds_to_win then
            self.game_over = true
        end
    else
        -- Tie
        self.ties = self.ties + 1

        -- Visual effects: screen flash (yellow for tie) - Phase 11
        if self.screen_flash_enabled then
            self.screen_flash_color = {1, 1, 0, 0.2}  -- Yellow flash (subtle)
            self.screen_flash_timer = 0.15
        end

        -- Phase 6 completion: Lives system - lose life on tie (if configured)
        if self.lives < 999 and (self.lose_life_on == "tie" or self.lose_life_on == "both") then
            self.lives = self.lives - 1
            if self.lives <= 0 then
                self.game_over = true
            end
        end
    end

    -- Update history
    table.insert(self.player_history, player_choice)
    table.insert(self.ai_history, self.ai_choice)

    -- Phase 6 completion: Update throw history for display
    if self.show_history_display then
        table.insert(self.throw_history, {
            player = player_choice,
            ai = self.ai_choice,
            result = self.round_result
        })
        -- Keep only last N throws
        while #self.throw_history > self.history_length do
            table.remove(self.throw_history, 1)
        end
    end

    -- Update metrics
    self.metrics.rounds_won = self.player_wins
    self.metrics.rounds_lost = self.ai_wins
    self.metrics.rounds_total = self.rounds_played
    self.metrics.max_win_streak = self.max_win_streak
    local total_decided = self.player_wins + self.ai_wins
    self.metrics.accuracy = total_decided > 0 and (self.player_wins / total_decided) or 0
    self.metrics.score = self.score

    -- Phase 6 completion: Save special round for display, then clear
    self.last_special_round = self.current_special_round
    self.current_special_round = nil

    -- Show result
    self.show_result = true
    self.result_display_time = 0
end

function RPS:generateAIChoice()
    -- Get available choices for current game mode
    local choices = self:getAvailableChoices()

    -- Phase 6 completion: AI pattern delay - use random until delay rounds have passed
    if self.ai_pattern_delay > 0 and self.rounds_played < self.ai_pattern_delay then
        return choices[self.rng:random(1, #choices)]
    end

    if self.ai_pattern == "random" then
        return choices[self.rng:random(1, #choices)]

    elseif self.ai_pattern == "repeat_last" and #self.ai_history > 0 then
        return self.ai_history[#self.ai_history]

    elseif self.ai_pattern == "counter_player" and #self.player_history > 0 then
        -- Throw what beats player's last choice
        local last_player = self.player_history[#self.player_history]
        local win_matrix = WIN_MATRICES[self.game_mode]
        if win_matrix and win_matrix[last_player] and win_matrix[last_player].loses_to then
            -- Pick randomly from options that beat the player's last choice
            local counters = win_matrix[last_player].loses_to
            return counters[self.rng:random(1, #counters)]
        end
        return choices[self.rng:random(1, #choices)]

    elseif self.ai_pattern == "pattern_cycle" then
        -- Cycle through choices in order
        local cycle_index = (#self.ai_history % #choices) + 1
        return choices[cycle_index]

    elseif self.ai_pattern == "mimic_player" and #self.player_history > 0 then
        -- Copy player's previous choice
        return self.player_history[#self.player_history]

    elseif self.ai_pattern == "anti_player" and #self.player_history >= 2 then
        -- Throw what player threw 2 rounds ago
        return self.player_history[#self.player_history - 1]

    else
        -- Default to random
        return choices[self.rng:random(1, #choices)]
    end
end

function RPS:generateAIChoiceForOpponent(opponent)
    -- Phase 6 completion: Generate AI choice for specific opponent
    local choices = self:getAvailableChoices()

    -- AI pattern delay
    if self.ai_pattern_delay > 0 and self.rounds_played < self.ai_pattern_delay then
        return choices[self.rng:random(1, #choices)]
    end

    -- Use opponent-specific pattern
    if opponent.pattern == "random" then
        return choices[self.rng:random(1, #choices)]

    elseif opponent.pattern == "repeat_last" and #opponent.history > 0 then
        return opponent.history[#opponent.history]

    elseif opponent.pattern == "counter_player" and #self.player_history > 0 then
        local last_player = self.player_history[#self.player_history]
        local win_matrix = WIN_MATRICES[self.game_mode]
        if win_matrix and win_matrix[last_player] and win_matrix[last_player].loses_to then
            local counters = win_matrix[last_player].loses_to
            return counters[self.rng:random(1, #counters)]
        end
        return choices[self.rng:random(1, #choices)]

    elseif opponent.pattern == "pattern_cycle" then
        local cycle_index = (#opponent.history % #choices) + 1
        return choices[cycle_index]

    elseif opponent.pattern == "mimic_player" and #self.player_history > 0 then
        return self.player_history[#self.player_history]

    elseif opponent.pattern == "anti_player" and #self.player_history >= 2 then
        return self.player_history[#self.player_history - 1]

    else
        return choices[self.rng:random(1, #choices)]
    end
end

function RPS:getAvailableChoices()
    -- Return available choices based on game mode
    if self.game_mode == "rpsls" then
        return {"rock", "paper", "scissors", "lizard", "spock"}
    elseif self.game_mode == "rpsfb" then
        return {"rock", "paper", "scissors", "fire", "water"}
    else
        -- Default RPS
        return {"rock", "paper", "scissors"}
    end
end

function RPS:determineWinner(player, ai)
    if player == ai then
        return "tie"
    end

    -- Get win matrix for current game mode
    local win_matrix = WIN_MATRICES[self.game_mode]
    if not win_matrix or not win_matrix[player] then
        return "tie"  -- Safety fallback
    end

    -- Check if player's choice beats AI's choice
    local beats_list = win_matrix[player].beats
    for _, beaten in ipairs(beats_list) do
        if beaten == ai then
            return "win"
        end
    end

    return "lose"
end

function RPS:checkVictoryCondition()
    -- Phase 6 completion: Check various victory conditions
    if self.victory_condition == "rounds" then
        -- Default: First to win X rounds
        return self.player_wins >= self.rounds_to_win

    elseif self.victory_condition == "first_to" then
        -- First to X wins (total)
        return self.player_wins >= self.first_to_target

    elseif self.victory_condition == "streak" then
        -- Win X consecutive rounds
        return self.current_win_streak >= self.streak_target

    elseif self.victory_condition == "total" then
        -- Get X total wins
        return self.player_wins >= self.total_wins_target

    elseif self.victory_condition == "time" then
        -- Best record when time runs out (checked in updateGameLogic)
        return false  -- Victory triggered by timer in update

    else
        -- Fallback to default
        return self.player_wins >= self.rounds_to_win
    end
end

function RPS:activateSpecialRound()
    -- Phase 6 completion: Randomly activate special rounds if enabled
    if not self.special_rounds_enabled then
        return nil
    end

    local available_specials = {}
    if self.double_or_nothing_enabled then table.insert(available_specials, "double_or_nothing") end
    if self.sudden_death_enabled then table.insert(available_specials, "sudden_death") end
    if self.reverse_mode_enabled then table.insert(available_specials, "reverse") end
    if self.mirror_mode_enabled then table.insert(available_specials, "mirror") end

    if #available_specials == 0 then
        return nil
    end

    -- 50% chance to activate a special round (makes them frequent enough to notice)
    if self.rng:random() < 0.5 then
        return available_specials[self.rng:random(1, #available_specials)]
    end

    return nil
end

function RPS:checkComplete()
    return self.victory or self.game_over
end

function RPS:draw()
    self.view:draw()
end

return RPS
